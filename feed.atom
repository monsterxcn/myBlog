<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.monsterx.cn/</id>
    <title>Monstx's Blog</title>
    <updated>2021-11-07T02:15:40.997Z</updated>
    <generator>Gridsome Feed Plugin</generator>
    <link rel="alternate" href="https://blog.monsterx.cn/"/>
    <link rel="self" href="https://blog.monsterx.cn/feed.atom"/>
    <subtitle>Monsterx CN - 学生 / 前端 / 电气</subtitle>
    <entry>
        <title type="html"><![CDATA[NoneBot 插件编写尝试]]></title>
        <id>https://blog.monsterx.cn/code/experiences-4-nonebot-2/</id>
        <link href="https://blog.monsterx.cn/code/experiences-4-nonebot-2/"/>
        <updated>2021-08-22T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>放假在家本来打算看看考研的书，结果硬是只看进去了一丁点皮毛。实在是受不了这种书看不进去无所事事的日子，于是给自己找了事情忙活。之前一直在用 <a href="https://github.com/Tsuk1ko/cq-picsearcher-bot">@Tsuk1ko/cq-picsearcher-bot</a>，上半年尝试了解了一些 Telegram bot 的东西还顺手给 PagerMaid 修了一个简单的插件 Bug，最近放假发现了好多好玩的 QQ 机器人项目…… 这些让我想自己写个机器人玩，于是便有了下文。</p>
<h2 id="go-cqhttp-和-nonebot">go-cqhttp 和 NoneBot</h2>
<p><a href="https://github.com/Mrs4s/go-cqhttp">@Mrs4s/go-cqhttp</a> 是「使用 mirai 以及 MiraiGo 开发的 cqhttp golang 原生实现」，在酷 Q 倒下之后感觉撑起了 QQ 机器人的半边天，在很多项目中都能看见他。通过 go-cqhttp 的各种 API 接口，开发者能使用 Node.js Python Golang C 等各种编程语言处理机器人收到的信息（Event），做进一步响应。<a href="https://github.com/nonebot/nonebot2">@nonebot/nonebot2</a> 便是一个能和 go-cqhttp 对接的「跨平台 Python 异步机器人框架」。</p>
<p>看了几遍《<a href="https://v2.nonebot.dev/guide/">概览 - NoneBot</a>》后，我觉得 NoneBot 是一个很方便的平台，有自己的脚手架可以快速创建项目；它的商店里所有插件都可供学习，Python 实现的机器人也有很多源码可供参考，官方文档没看懂可以找些大佬写的例子看看；上半年有一小阵子折腾 Telegram bot 时看了一些 Python 的代码，了解了最基本的插件是如何工作的。这些经验让我决定了使用 nonebot2。</p>
<p>go-cqhttp 和 nonebot2 的安装和配置均可参考对应文档。最终 nonebot2 的项目文件夹可以通过 <code>nb create</code> 快速创建，nonebot2 通信协议 Adapter 选用官方维护的 <code>nonebot-adapter-cqhttp</code> 即可，使用 <code>nonebot_adapter_gocq</code> 可能会存在兼容性问题。go-cqhttp 的反向 WebSocket Universal 地址需要配置为 <code>http:///[HOST]:[PORT]/cqhttp/ws</code>，其中 <code>[HOST]:[PORT]</code> 和 nonebot2 <code>.env</code> 中的配置保持一致，我尝试填写别的地址时连接不上。先登陆一次 go-cqhttp 生成 data device.json 等文件夹和文件，启动机器人时先使用 <code>nb run</code> 或 <code>python3 bot.py</code> 启动 NoneBot，然后进入 go-cqhttp 文件夹下启动 go-cqhttp。在 NoneBot 输出中看到 <code>WebSocket Connection from CQHTTP Bot NNNNNNNNNN Accepted!</code> 就算成功！</p>
<h2 id="虚拟环境-venv">虚拟环境 venv</h2>
<p>初次尝试 NoneBot 后我发现通过 <code>pip</code> 安装插件的方式虽然方便，但是很容易出现依赖版本冲突，这时候虚拟环境就显得很重要。这也是我第一次尝试虚拟环境。NoneBot 推荐使用 Poetry，但我用了下不太习惯，尤其是最新版本的 <code>nb-cli</code> 创建的项目文件夹中 <code>pyproject.toml</code> 依赖却是低版本的。最终我还是选择了 <code>venv</code>。</p>
<pre><code class="language-bash"># 安装 venv
python3 -m pip install venv
# 在 /path/to/thisvenv 文件夹下创建一个虚拟环境
python3 -m venv /path/to/thisvenv

# 进入 /path/to/myBots 文件夹并启用虚拟环境
cd /path/to/myBots
source /path/to/thisvenv
# 启用后命令行前会多出当前虚拟环境的名字
(thisvenv) user@host: myBots$

# 使用 pip 安装各种依赖
# pip install -i https://pypi.tuna.tsinghua.edu.cn/simple packagename
pip install nb-cli nonebot-adapter-cqhttp

nb create
cd abot
# ...
nb run

# 退出虚拟环境
deactivate
</code></pre>
<p>如果创建虚拟环境时使用 <code>python3</code> 那么在虚拟环境中 <code>python</code> 和 <code>pip</code> 也都指向最新版本。在整个项目完成后可以生成当前环境中各种依赖版本：</p>
<pre><code class="language-bash">pip freeze &gt; requirements.txt    # 备份当前的依赖版本

pip install -r requirements.txt  # 安装指定的依赖版本
</code></pre>
<h2 id="第一个插件">第一个插件</h2>
<p>根据《<a href="https://v2.nonebot.dev/guide/creating-a-plugin.html">创建插件 - NoneBot</a>》的指导并参考众多 NoneBot 插件做法，插件目录一般为 <code>src/plugins</code>，在其中创建一个文件夹或单个文件都可以被 NoneBot 加载为插件。</p>
<p>我的第一个插件是用于获取 Epic Game Store 限时免费游戏的，因为某天打开群时看到有人说 <a href="https://github.com/DIYgod/RSSHub">@DIYgod/RSSHub</a> 的 Epic <a href="https://docs.rsshub.app/game.html#epic-games-store">免费游戏</a> 不能用了，我第一感觉就是他懒没有自己部署罢了…… 我自己去部署了一下果然还是好使的。看了看这个路由的 <a href="https://github.com/DIYgod/RSSHub/tree/master/lib/routes/epicgames">源码</a>，感觉还挺好玩的。于是决定将他改成机器人插件。</p>
<p>这种插件的形式是检测到符合要求的命令之后，向某个网站 API 发起 HTTP 请求，根据返回的信息（一般是 JSON）处理之后返回给用户。机器人的大多数功能都可以通过这种形式写出来，因为网上各种可供调用的 API 实在是太多了，什么搜图、翻译、段子、涩图、天气、查快递都有（好像混入了奇怪的东西）。@DIYgod/RSSHub <code>/epicgames/freegames</code> 路由的实现方法特别之处是向 Epic 的 GraphQL 服务器发起 <code>query</code> 查询请求，我见得少觉得很新颖。</p>
<p>NoneBot 最大的特点就是「异步」，所以发起 HTTP 请求的方式不推荐用 <code>requests</code>，自带的 <code>httpx</code> 或者 <code>aiohttp</code> 都是很合适的异步网络请求工具，这里给出改写后的 <code>httpx</code> 实现。</p>
<pre><code class="language-python"># async 定义一个异步函数，NoneBot 中插件的函数大都以此定义
async def get_Epicgame():
  # 发起请求的地址
  epic_url = &quot;https://www.epicgames.com/store/backend/graphql-proxy&quot;
  # HTTP 请求的 Headers
  headers = {
    &quot;Referer&quot;: &quot;https://www.epicgames.com/store/zh-CN/&quot;,
    &quot;Content-Type&quot;: &quot;application/json; charset=utf-8&quot;,
  }
  # 要发送的 JSON 数据包，query 部分不完整
  data = {
    &quot;query&quot;: &quot;query searchStoreQuery($allowCountries: String, ... &quot;,
    &quot;variables&quot;: {
      &quot;allowCountries&quot;: &quot;CN&quot;,
      &quot;category&quot;: &quot;freegames&quot;,
      &quot;count&quot;: 1000,
      &quot;country&quot;: &quot;CN&quot;,
      &quot;locale&quot;: &quot;zh-CN&quot;,
      &quot;sortBy&quot;: &quot;effectiveDate&quot;,
      &quot;sortDir&quot;: &quot;asc&quot;,
      &quot;withPrice&quot;: True,
      &quot;withPromotions&quot;: True
    }
  }
  # 使用异步 API 创建 Client，HTTP Headers 可以在此传递
  async with AsyncClient(headers=headers) as client:
    try:
      # 通过 json=data 的方式传递上面定义的 JSON 数据，发起 POST 请求
      res = await client.post(epic_url, json=data, timeout=10.0)
      # res 为获取到的数据，通过 .json() 转为 JSON 数据
      resJson = res.json()
      # 简单的挑选响应结果中有用的部分
      games = resJson[&#39;data&#39;][&#39;Catalog&#39;][&#39;searchStore&#39;][&#39;elements&#39;]
      return games
    except Exception as e:
      logger.error(str(e))
      return None
</code></pre>
<p>这样一个简单的能执行 HTTP 异步请求的函数就写好了，在调用异步函数的地方使用类似 <code>res = await asyncFunctionName()</code> 的语句。为了测试这一函数是否可用，我通常会将其单独拎出来，放在下面这样的文件中单独执行测试。</p>
<pre><code class="language-python">import asyncio
import httpx

async def main():
  # ...
  async with httpx.AsyncClient() as client:
    response = await client.get(&#39;https://www.example.com/&#39;)
    # ...
    print(response)     # return 改为 print

asyncio.run(main())
</code></pre>
<p>像这种获取数据供插件使用的函数 NoneBot 推荐写在插件文件夹下 <code>data_source.py</code> 里。在其他需要的地方通过 <code>import</code> 导入。关于 <code>httpx</code> 的更多操作可以在《<a href="https://www.python-httpx.org/quickstart/">QuickStart - HTTPX</a>》中查找，现学现卖完全够用。</p>
<p>回到此插件，获取到 HTTP 响应的数据之后还需要挑选其中有用的部分，我这里获取的 JSON 数据包含了拥有折扣的众多游戏信息，为了挑选出其中的限免游戏我写了另外一个函数 <code>get_Epicfree()</code> 放在 <code>data_source.py</code> 里。这里讲个插曲，写完获取数据的函数后我才发现 python 原来已经有写好的包可以直接用 <a href="https://github.com/SD4RK/epicstore_api">@SD4RK/epicstore_api</a>，而且这个包里给出了更多 <code>query</code> 查询语句，免费游戏的例子他也写出来了。好家伙，处理 JSON 数据的逻辑我直接照搬，省下了大把功夫。</p>
<p>这样 <code>data_source.py</code> 的大部分功能就完成了，接下来新建 <code>__init__.py</code> 文件，这里将告诉机器人插件何时响应用户，如何响应用户。</p>
<pre><code class="language-python">from nonebot import on_regex
from nonebot.typing import T_State
from nonebot.adapters.cqhttp import Bot, Event, Message

# 导入 .data_source 里需要用到的函数
from .data_source import get_Epicfree

# 注册了一个事件响应器 matcher，这里只要符合正则就响应
matcher = on_regex(&quot;((E|e)(P|p)(I|i)(C|c))?喜(加一|\+1)&quot;, priority=1)
# 事件响应器 matcher 的事件处理函数
@matcher.handle()
async def handle(bot: Bot, event: Event, state: T_State):
  # 异步调用 data_source 里的函数
  # 我的 get_Epicfree 里调用了发起 HTTP 请求的 get_Epicgame 并处理出最终的消息文本
  imfree = await get_Epicfree()
  # 有的时候需要使用 Message() 将对象转换为可用的消息对象
  msg = Message(imfree)
  # 事件响应器的 finish() 结束事件响应，此外还有 send() 等可用
  await matcher.finish(msg)
</code></pre>
<p>如此，一个最基本的插件就做好了。重新启动 NoneBot 后启用此插件。关于这个插件的所有代码均可在仓库 <a href="https://github.com/monsterxcn/nonebot_plugin_epicfree">@monsterxcn/nonebot_plugin_epicfree</a> 查看。你也可以通过 <code>nb</code> 或 <code>pip</code> 安装 <code>nonebot_plugin_epicfree</code> 体验。</p>
<h2 id="pillow-画图插件">Pillow 画图插件</h2>
<p>很多时候咱有发图片的需求，比如「无内鬼，搞点…」什么的，其中图片除了像第一个插件一样通过请求 API 返回图片的 URL，有的时候可能还需要添加一些细节。比如 <a href="https://github.com/Xtao-Labs/PagerMaid_Plugins">@Xtao-Labs/PagerMaid_Plugins</a> Telegram 人形自走机器人插件仓库中的吃 / 丢用户头像功能，需要获取用户的头像然后自行拼接到背景图片上；又比如我想做一个原神每日素材的功能，事先准备好了各种素材对应角色或武器的图片，希望机器人来处理拼接这些图片成为当日素材。</p>
<p>这里就以原神每日素材的功能需求为例，交代我的实现方法。@Xtao-Labs/PagerMaid_Plugins 中的功能可以作为进阶操作，我自己也照着原仓库代码改写出来了，但是代码理解的不够深，就不拿出来献丑了，说不定什么时候没人我就悄咪咪传到 Gist 存个档留念。</p>
<p>各种素材图片来源于 <a href="https://genshin.pub/daily">今日素材表 - 可莉特调</a>，我通过 Chrome 开发者工具中 <code>Ctrl</code> <code>Shift</code> <code>P</code> 调用 <code>[Screenshot] Capture node screenshot</code> 手动获取，算是个笨办法了。将每种素材对应截取一张图片，3 个区域 18 种素材 18 张图片，分别命名成 <code>{区域名}.{星期数}.png</code> 的格式。我还另外截取了「今日素材可升天赋角色」「今日素材可突破武器」两张头图，命名为 <code>header.png</code>。</p>
<p>接下来编写 <code>getMaterial(type)</code> 函数用来获取包含了 <code>type</code> 对应头图和蒙德、璃月、稻妻三个区域 <code>type</code> 对应素材图片的 <code>Image</code> 类型列表，函数内调用 <code>datetime</code> 库获取当日星期数。<code>Image</code> 类型是 Python 绘图库 <code>Pillow</code> 内定义的，它包含了图片的色彩模式、像素大小等信息，使用 <code>image.open(filename)</code> 或者 <code>Image.new()</code> 均可得到一个 Image 类型的对象。</p>
<pre><code class="language-python">async def getMaterial(type):
  day = datetime.today().weekday() + 1    # 星期一对应 1，星期日对应 7
  imgList = []                            # 存放 Image 类型数据的列表，默认为空
  filename = f&#39;{type}.{day}.png&#39;          # 供后续调用，是将要生成的图片名
  width, height = (0, 0)                  # 供后续调用，是将要生成的图片大小，默认为 0
  if day != 7:
    daily = day if day &lt; 4 else day - 3   # 周四周五周六素材分别于周一周二周三相同
    countries = [&quot;Mondstadt&quot;, &quot;Liyue&quot;, &quot;Inazuma&quot;]
    # 通过 append() 将 Image.open() 获取的 Image 类型数据加入列表
    imgList.append(Image.open(resPath + f&quot;{type}/header.png&quot;))  # 头图
    for country in countries:
      # 遍历三个区域，取出所需 type 的素材分图
      image = resPath + f&quot;{type}/{country}.{daily}.png&quot;
      imgList.append(Image.open(image))
    # 遍历生成的 Image 类型数据列表，获取即将生成的图片总高度、总宽度
    for img in imgList:
      w, h = img.size
      height += h              # 高度累加，后续我将图片列表的 Image 从上到下拼接
      width = max(width, w)    # 宽度为最大的宽度，实际我的图片宽度都一样
  return imgList, width, height, filename
</code></pre>
<p>好，这个函数将返回包含待处理图片的 Image 类型列表、预计生成图片的宽度和高度、待生成的图片名。如果时间为周日则返回一个空的列表，后续可以判断列表是否为空决定最终返回的消息。因为周日所有素材均可获取。接下来编写画图的函数，这部分可能需要结合《<a href="https://pillow.readthedocs.io/en/stable/">Pillow - Pliiow (PIL Fork) Documentation</a>》相关函数的说明理解。不过此例还算简单了，基本只用到了一个粘贴的函数 <code>Image.paste()</code>，如果要实现前面所说的吃头像功能还要到文档里学习更多。</p>
<pre><code class="language-python">async def msgTranslate(imgList, totalWidth, totalHeight, saveAs):
  if imgList == []:
    return &quot;哈！今天是周日，所有天赋秘境和武器秘境全部开放哦🥰&quot;
  else:
    # 新建一个 Image 对象，颜色制式与 imgList[0] 一样，背景颜色为纯色 #F6F2EE
    result = Image.new(imgList[0].mode, (totalWidth, totalHeight), &quot;#F6F2EE&quot;)
    drawFromHeight = 0        # 初始绘制时的动作点高度
    for img in imgList:
      w, h = img.size         # 获取当前图片的宽度、高度
      # 向 result 这个 Image 中粘贴 img，box 的参数是粘贴图片的左上角坐标
      result.paste(img, box=(round(totalWidth / 2 - w / 2), drawFromHeight))
      drawFromHeight += h     # 一张图片粘贴完后累加高度
    result.save(saveAs)       # 将 Image 对象 result 保存为文件 saveAs，注意要带上完整路径
    msg = f&quot;[CQ:image,file=file://{saveAs}]&quot;
    return msg
</code></pre>
<p>如此，图片就绘制好了，<code>result</code> 是一个 Image 类型数据，并不能直接通过 NoneBot 发送。使用 <code>result.save(&quot;/path/to/.png&quot;)</code> 可以将其生成为一张图片，这样使用 CQ 码 <code>[CQ:image,file=file:///path/to/.png]</code> 就可以发送出去了。</p>
<p>最后是事件响应器，我在 <code>__init__.py</code> 中使用了如下逻辑：</p>
<pre><code class="language-python">materialMatch = on_command(&#39;今天打什么&#39;, priority=1)
@materialMatch.handle()
async def send_mt(bot: Bot, event: GroupMessageEvent, state: T_State):
  # 获取消息。比如发送了「今天打什么天赋」后 bot 会获取到 searchFor=&#39;天赋&#39;
  searchFor = str(event.get_message())
  if searchFor == &#39;天赋&#39; or searchFor == &#39;武器&#39;:
    type = &#39;talent&#39; if searchFor == &#39;天赋&#39; else &#39;weapon&#39;
    # 调用刚才编写的两个函数
    material = await getMaterial(type)
    msg = await msgTranslate(material[0], material[1], material[2], material[3])
    # 发送消息，也可以先将图片转为 Base64 编码再发送
    await materialMatch.finish(Message(msg))
  else:
    # 没有检测到要打什么
    await materialMatch.finish(Message(&quot;打什么？[CQ:face,id=32]&quot;), at_sender=True)
</code></pre>
<p>当然以上这些只是大概讲了下我做这个功能的思路，还有一些细节可以优化优化，比如：这里只简单判断了星期数，没有判断时间是否过了凌晨 4 点；图像是每次使用时都重新生成，也没有做缓存。完整的代码我可能什么时候觉得整理得差不多了再放到 GitHub。</p>
<h2 id="heu-定时打卡插件">HEU 定时打卡插件</h2>
<p>写了两个插件之后我觉得自己还蛮厉害的，于是开始想办法将之前做的学校疫情打卡实现到机器人上。最近疫情有所反弹，学校又开始了返校前的打卡活动。另外大家都要注意防疫哦。</p>
<p>打卡的插件原本是需要自己获取 <code>formData</code> <code>boundFields</code> 等参数的，还要处理 HEU CAS 认证的相关 Cookies 等，如何使用 <code>httpx</code> 实现这些功能我还不太理解，于是妥协以模拟浏览器操作的方式实现。这里使用了 <a href="https://github.com/microsoft/playwright-python">@microsoft/playwright-python</a>，它是个不错的自动化测试工具。通过 <code>pip</code> 安装好 <code>playwright</code> 后，还需要执行一次 <code>playwright install</code> 让 <code>playwright</code> 安装可用的浏览器组件及 <code>ffmpeg</code>。我本来以为国内服务器上安装 <code>chromium</code> 可能会卡住，不过实际用阿里云北京的服务器试了一下并没出现网络问题。</p>
<p>与前述步骤一样，最好的参考文档仍然是《<a href="https://playwright.dev/python/docs/intro">Getting Started - Playwright Python</a>》。实现打卡部分的代码我已经放在了 Gist <a href="https://gist.github.com/monsterxcn/f0a7a083ee65d52b1400596ace43687b#file-nonebot_plugin_checkin-py-L53-L98">@monsterxcn/nonebot_plugin_checkin.py</a> L53-98。感觉结合文档比较容易理解，看函数名也容易理解是什么作用，总之 Playwright 是很好上手的。</p>
<p>接下来是定时任务的实现，这需要安装 NoneBot APScheduler 定时任务插件 <a href="https://github.com/nonebot/plugin-apscheduler">@nonebot/plugin-apscheduler</a>，参考仓库里的「使用方法」即可。在 <code>__init__.py</code> 中定义定时任务，比如实现定时打卡的功能可以这么写：</p>
<pre><code class="language-python">scheduler = require(&quot;nonebot_plugin_apscheduler&quot;).scheduler
@scheduler.scheduled_job(&quot;cron&quot;, hour=6, minute=6, second=6)
async def auto_checkin():
  # 获取 bot 信息
  (bot,) = nonebot.get_bots().values()
  for customer in customers:
    # 拼接 CQ 码 at 某人
    msg = f&quot;[CQ:at,qq={customer}] &quot;
    try:
      # 传入了最后一个参数 mode=auto，打卡任务将不输出执行过程提示
      msg += await checkin(customers[str(customer)][0], customers[str(customer)][1], &#39;auto&#39;)
      await bot.send_group_msg(group_id=GROUPNUMBER, message=Message(msg))
    except Exception as e:
      logger.error(str(e))
      # 如果定时任务执行出错了将向管理员用户私信报错信息
      await bot.send_private_msg(user_id=ADMIN, message=f&quot;{customer}(学号{customers[str(customer)][2]}) 今日打卡定时任务执行出错了！&quot;)
</code></pre>
<p>这里值得注意的是在定时任务事件处理函数中如何调用机器人主动发送消息，这种方法在其他场合应该也是通用的。首先通过 L5 获取 <code>bot</code> 对象，然后通过 <code>_ApiCall</code> 方式调用 go-cqhttp API，比如 L12 L16 分别调用了发送群消息、发送私聊消息的接口。</p>
<p>通过此插件主要学习了 Playwright Python 的使用和定时任务的添加。完整插件的代码可以通过前面的 Gist 链接查看。如果有时间我觉得还可以添加上 JSON 操作：将学号密码写入 JSON，执行时读入，判断不存在后令用户输入并写入 JSON。</p>
<h2 id="连续对话的抽签插件">连续对话的抽签插件</h2>
<p>做原神每日素材插件的时候，我就想整一个像可莉特调那样的原神黄历、抽签功能。撸完了定时打卡的插件之后我又看了看 Playwright 文档，发现它不仅能用来模拟浏览器操作执行打卡，还带有 <code>screenshot()</code> 函数可以实现网页截图，<code>inner_text()</code> <code>inner_html()</code> 函数可以用来做爬虫。我一拍脑袋，想法有了：通过 Playwright 写一个爬虫爬取诸葛神算测字三百八十四爻（也就是可莉特调使用的运势签），再通过 <code>screenshot()</code> 截取指定选择器的网页截图（使用 Pillow 绘制的话感觉会很麻烦）。写这部分代码参考了群友的机器人 <a href="https://github.com/FYWinds/takker">@FYWinds/takker</a> 和 Playwright 文档。</p>
<p>爬虫的编写不在此讲解，思路其实很简单，代码见 Gist <a href="https://gist.github.com/monsterxcn/47681a6db630887d69946cc7f0faa0e6">@monsterxcn/chims-crawler.py</a>。爬到的三百八十四签我也都顺便放在了这个 Gist 里，可以直接拿来用。至于为什么不用网上大把的抽签接口，我是觉得既然决定要折腾，那不如就折腾到底。</p>
<p>Playwright 网页截图也很好实现，与上面插件类似，在打开网页后使用下面这样的语句即可：</p>
<pre><code class="language-python">async with async_playwright() as p:
  browser = await p.chromium.launch()
  page = await browser.new_page()
  # 这里打开的本地 html 文件是接下来我要做的抽签模板文件
  await page.goto(f&quot;file://{resPath}card/tmp.html&quot;)
  # 设置网页窗口大小
  await page.set_viewport_size({&quot;width&quot;: 1920, &quot;height&quot;: 1080})
  # 等待指定选择器加载
  chim = await page.query_selector(&quot;.container&quot;)
  assert chim is not None
  # 截图到路径 {resPath}card/ 文件夹下 tmp.png
  await chim.screenshot(path=f&quot;{resPath}card/tmp.png&quot;)
</code></pre>
<p>那么如何实现抽签功能呢？我的思路是使用随机数 <code>random.randint(1, 384)</code> 生成签号，然后读取 JSON 文件取出对应签号的签的信息。接下来打开事先编写好的卡片 HTML 模板，使用 <code>replace(&quot;模板中的占位符&quot;, &quot;签的信息&quot;)</code> 替换并保存一个临时文件。执行 Playwright 指定选择器的网页截图。</p>
<p>卡片 HTML 模板我已经放在了 <a href="https://gist.github.com/monsterxcn/d933cafcdc6662c6bdcbd561fe921e8c">Gist</a>，样式参考可莉特调做了一些调整，字体使用原神游戏客户端的文件即可，路径如下：</p>
<pre><code>Genshin Impact\Genshin Impact Game\YuanShen_Data\StreamingAssets\MiHoYoSDKRes\HttpServerResources\font
</code></pre>
<p>读取 <code>.json</code> 使用了自带的 <code>json</code> 库，我将卡片模板分别命名为抽签 <code>poem.html</code> 和解签 <code>intp.html</code>。生成图片时调用的是同一个函数，通过参数决定使用哪一个模板。由于无论是之前生成的随机数还是 json 文件中的签号均是阿拉伯数字，写入模板时，还需要一个将阿拉伯数字转换为中文繁体数字的函数，这个算是小细节。代码不难，我就不放在这里占用篇幅了。</p>
<p>这个插件最后一个点是如何连续对话：发送抽签命令后机器人发出了一张图片，接下来应该询问是否需要解签，根据用户回答决定整个流程是否结束。这里用到的是《<a href="https://v2.nonebot.dev/2.0.0a7/api/matcher.html#classmethod-got-key-prompt-none-args-parser-none">Nonebot.matcher 模块 - NoneBot</a>》的 <code>got()</code> 函数，文档里介绍得不多，我学得也比较蒙，但是最后写出来还是能用的：</p>
<pre><code class="language-python"># __init__.py

chimMatch = on_command(&#39;抽签&#39;, priority=1)
@chimMatch.handle()
async def chim(bot: Bot, event: GroupMessageEvent, state: T_State):
  try:
    # getChim 函数用来生成随机数并读取 JSON 输出签号、吉凶、签诗、解签
    # 将其赋值进 state[] 可以在下面 got() 中继续调用，chimNum 这些都是自己定义的
    state[&quot;chimNum&quot;], state[&quot;chimLuck&quot;], state[&quot;chimPoem&quot;], state[&quot;chimIntp&quot;] = await getChim()
    # genrChimImg 函数用来读取模板并替换占位符为签的内容，最后一个参数用来决定使用哪个 HTML 模板
    chimImg = await genrChimImg(state[&quot;chimNum&quot;], state[&quot;chimLuck&quot;], state[&quot;chimPoem&quot;], &quot;poem&quot;)
    await chimMatch.send(Message(chimImg), at_sender=True)
  except Exception as e:
    logger.error(str(e))
    await chimMatch.finish(&quot;抽签发生了错误🤕&quot;)

# got() 指示当 action 不存在时发送 prompt 消息并接收用户新的一条消息
@chimMatch.got(&#39;action&#39;, prompt=&#39;你需要解签吗？&#39;)
async def _(bot: Bot, event: GroupMessageEvent, state: T_State):
  if &quot;不&quot; in state[&#39;action&#39;]:
    # 用户说了包含「不」得句子就判定为不需要解签，结束流程
    await chimMatch.finish(&quot;好吧&quot;)
  else:
    try:
      # 从 state[] 读取签的信息，这样不用重新读 JSON，传入最后一个参数用来决定使用解签的 HTML 模板
      intpImg = await genrChimImg(state[&quot;chimNum&quot;], state[&quot;chimLuck&quot;], state[&quot;chimIntp&quot;], &quot;intp&quot;)
      await chimMatch.finish(Message(intpImg))
    except Exception as e:
      logger.error(str(e))
      # await chimMatch.finish(&quot;解签发生了错误🤕&quot;)
</code></pre>
<p>好啦，这个能连续对话、实现抽签解签功能的插件就做好了！主要学习了 NoneBot <code>matcher.got()</code> 和 Playwright <code>page.screenshot()</code>，前者让机器人能从后续对话中获取变量决定程序走向，后者能在 Pillow 绘图较复杂不易实现时提供替代方案。</p>
<hr>
<p><img src="https://blog.monsterx.cn/code/experiences-4-nonebot-2/images/post/nonebot-plugins.png" alt="NoneBot 插件效果"></p>
<p>本来以为这点经验写不了多少的，结果码点代码、加点注释就撑起了大半篇幅，希望读者有所收获！Python 新手难免出错，如果你发现了欢迎指正！( •̀ ω •́ )y</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[手帐 · 生死]]></title>
        <id>https://blog.monsterx.cn/life/daily-death/</id>
        <link href="https://blog.monsterx.cn/life/daily-death/"/>
        <updated>2021-05-30T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>3 月里的一天，姐姐给我发来一条 QQ 消息：爷爷去世了…… 我心里咯噔一下，爷爷的面庞浮现在眼前，我不敢相信，心里一时间还没有什么特别悲伤的感觉。接下来的几天我在 QQ 上看到姐姐断断续续给我发的照片，遗像、棺材、披麻戴孝的人、骨灰盒、路边的鞭炮屑、那座熟悉的山和家里下着的雨，我才意识到自己永远地失去了爷爷，几年前的一个暑假还和爷爷怄气的我悔恨难当。下葬那天，我在没人的地方朝着家的方向磕了三个头。我没有流泪。</p>
<p>这并不是第一次遇见亲人离世，但确实是最亲的人离开。初中时姑姑走了，父母带着我去那边，我虽然和姑姑不常见面、不甚亲热，但看到那场面还是忍不住痛哭，莫名的伤悲在看见遗像时一下子涌上心头，看着周围的人和事眼泪就止不住的流下来。这件事家里人都瞒着爷爷，可能是因为不知道如何交待、加之担心爷爷身体。去年姑爷肺癌也走了，家里人才不得不将这些事告知爷爷，那天晚上爷爷为此动怒，这是我第一次看见爷爷生气…… 姑爷的葬礼父母没有带我去，我只感觉生死之事如此无常，哭也无法挽回，这种事就让时间冲淡好了。但是，无常再临，自己却又不愿接受了。</p>
<p>周末，我忐忑地拨通了爸爸的电话，我装作无事发生，爸爸亦是如此。像往常一样我说完了自己的事后等着爸爸那边回音，但是电话两边都安静了下来，过了一会只听见爸爸无奈地说了声「本来有件不好的事想对你讲，但是看你好像没什么感觉我就不了讲了」（爸爸说的「感觉」是因为他问了我在这边有没有什么感觉，大概是心灵感应的意思，我回了他没有）。那个时候，谁都不愿提起这件「不好的事」，但是双方都心知肚明。这么多天以来，一直强迫自己不去面对，而在听到爸爸的这句话之后，泪水便像决堤的洪水一样。悲伤涌上心头，抽泣着的我回了句「你们在家好好的就好」。爸爸一愣，接着追问我是谁告诉我的、什么不是说好了先不告诉你的吗云云。接着我把我的伤心与悔恨一股脑倾泻出来，爸爸则不停地安慰我，说爷爷不会因为那些小事怪我，也不会因为我没回家去怪我…… 但我不能原谅自己。</p>
<p>挂断电话，妈妈给我发了条微信让我别伤心，也别让爸爸伤心。我才缓过来，爸爸才是最伤心的那个人啊。我想起来：平时从不厌烦和听力不好的爷爷大声说话的人是爸爸，责备妈妈做菜不考虑爷爷、给爷爷不停夹菜的是爸爸，半懂不懂却还要笨拙地教爷爷用微信的是爸爸…… 为了爷爷，爸爸不惜和妈妈拌嘴，引得妈妈生气。现在，爷爷在爸爸离开家的片刻出了意外，爸爸心里该有多自责多难过？而电话里一直到哭甚至还想埋怨爸爸为什么不把爷爷看护好的我是有多么幼稚！</p>
<h2 id="忆">忆</h2>
<p>爷爷是一个爱看书的人。他在家时总是伏在桌前，看着各种各样的书，有的时候是小说传记诸如《刘伯温传》、有的时候是报纸杂志如《参考消息》、有的时候是我买的课外书。以前学校老师要求我写日记的时候，爷爷也爱悄咪咪看我写的东西（我其实很不愿意把日记给别人看，除了不得不交予检查的老师），据爷爷说他其实早就从我的日记里知道了姑姑的事，一直在等着，看家里人到底要瞒他到什么时候。爷爷的桌贴着窗子，桌上放了面镜子刚好能反射到门口巷子那里，我没问过爷爷那个镜子是干嘛的，我猜测应该是方便爷爷在桌前看书时一抬头就能看到门口有什么人来吧。我现在再没有机会亲口问爷爷那个镜子究竟是用来干嘛的了。爷爷的眼睛有些浑浊，但看书却一直没什么问题，他还总是拿只笔在纸片上抄写着句子。我也看过他写的那些句子，很多都是一些为人处世的哲理。说起爷爷的字，我想起来爷爷的毛笔字写得非常好看，只是年纪大了他拿不稳毛笔，这几年里我几乎没再看见过爷爷写毛笔字。只有以前过年的时候，爸爸会把笔墨红纸准备好，怂恿我动手写写毛笔字，这个时候我就总是十分期待让爷爷拿起毛笔，爷爷写完字的时候总是会笑着说手不稳了、写字不好看了这样谦虚的话……</p>
<p>爷爷爱看戏曲，不知道是庐剧还是黄梅戏。也是以前的时候，如果家里没人要看电视，爷爷就会在家里的大屁股电视机上放戏曲碟片。那些碟片不知道是什么时候买的了，落满了灰尘，塑料外壳也快要坏了，一直堆在大屁股电视机后面。看戏的时候爷爷坐得离电视很近，声音也要开到最大，以至于电视机里发出嗡嗡的响声。这样他才能好好享受戏曲。后来爷爷听力衰退得厉害，我和他说话都要贴着他的右耳，他才勉强能听见，平时别人和他说话他则要结合着听到的微弱声音猜测半天；再加上大屁股电视机换成了联网的平板电视，我估计是这些原因，爷爷不再用电视机看戏了。平时看电视时，他都是坐在离屏幕很近的地方，费劲地盯着那些跑来跑去的字。家里换上这种带电视盒子的平板电视之后，爷爷不怎么会用，我又懒得教他，总是拿一句「你自己多按按试一试不就知道了吗」敷衍他，以至于他偶尔会把电视机调到莫名其妙看不了卫视的界面，妈妈就怪爷爷又把电视看坏了。也许正是如此，爷爷愈加不敢播那些落满了灰尘的戏曲碟片了。</p>
<p>爷爷总是收集我觉得没用的东西，应该也是个挺有好奇心的人。家里的桌子抽屉里总是被塞得满满当当，里面装着螺丝、钉子、线团、褪色报纸包裹着的物件。平时我总是觉得那些东西留着有什么用，啥都往抽屉里放，但是有的时候，却正是在这些自己觉得没用的东西里，我找到了需要的玩意儿。就好奇这点，我买的杂志他总是会拿来看，《意林》《读者》、《少年博览》、甚至我认为他应该很多都看不懂的《科学 Fans》。我买的电子设备和小玩意被淘汰后爷爷也会把它们收起来，可能会在一个人的时候充上电摆弄摆弄。智能手表手环流行的时候爷爷也时常带着手环，把自己的机械手表放在一边。家里人都用上智能手机之后，爷爷也会想要一台智能手机。有了智能手机之后，爷爷在家人的帮助下注册了微信，和家里人都加上了微信，堂哥、大姑他们好像经常和爷爷聊微信，而我却在加了微信之后没给爷爷发过一条消息，一个字都没有。爷爷总是抱怨手机上又提示垃圾太多、内存已满之类的，让我帮他清理。清理了几次之后我就放弃了，微信这种笨重的软件在安卓四的机器上要我怎么优化？家里人明明都挺能挣钱，怎么就是不肯花点钱给爷爷买个新一点的手机呢！去年换了手机之后，我在想就把自己淘汰的手机修好给爷爷用，微信应该都不至于会卡吧？但是再没有这个机会了。</p>
<p>爷爷会自己动手做很多玩意儿，虽然有些很简陋但却有趣。家里有个不小的菜园，菜园边上不远有一片片竹子。放学回家有的时候就能看到爷爷在破竹篾，然后编得整整齐齐，最后变成菜园的新围墙。菜园边角的地方有爷爷种的小葱，那些小葱割了一茬又一茬，变成蒸蛋上的一缕缕清香。小葱总是能顽强不息地长回来，人要是也有这样的生命力就好了！有的时候爷爷从竹园里砍来竹子，把竹枝劈下来，捋一捋、扎一扎，再砍一截竹竿打磨光滑，将整理好的竹枝固定在竹竿末端，一把大扫帚就做好了。岁月流逝，我很少再看见爷爷闲来无事坐在门口做东西了。当我拿起爷爷做的大扫帚扫院子时，爷爷就在门口看着我，笑着说自己做的扫帚太重了拿不动。家里的水池没有清理用的刷子，爷爷就用竹篾捆一扎，再用砍刀刀背将竹篾砸开，这就成了把称手的刷子。水池的塞子不好拔，爷爷把不用的筷子固定上去，塞子变成了搋子，虽然有点脏不好看，却能让我不湿手就把水池放干。年幼的我很羡慕、崇拜爷爷总是能做出各种各样的工具来。因为经常看见爷爷做东西，我小的时候闲着也喜欢带着那把砍刀欺负竹子、带着锄头到后院挖宝藏……</p>
<p>爷爷爱吃咸的，并且总是把自己喜欢吃的塞给我们，让我们也吃吃。放寒假的时候，我还和爷爷一起吃早饭，爷爷煮的粥我最爱吃了。他晚上用电饭锅定时煮粥，早晨九、十点钟的时候我才下床洗漱，之后爷爷就会盛满满一碗白米粥给我，桌上摆满了咸菜、咸蛋、腐乳、酥糖，有的时候还有爷爷在我躺床上的时间里上街买的包子、煎饺、锅贴。我不怎么喜欢吃酥糖，但是感觉爷爷喜欢吃；腐乳我以前也不怎么吃，感觉有点酒味，但是爷爷好像挺喜欢吃，隔三差五就买白腐乳、红腐乳。我其实觉得粥就能直接下肚了，但爷爷总是说我「怎么净吃寡粥不吃菜呢」，然后把腐乳罐头盖子拧开让我夹点、或者把咸蛋袋子撕开、有的时候甚至还要把剥干净的咸鸭蛋递给我。我正好想尝尝得话就开心地接下了，但有时我却又感到不耐烦，嘴里哼哼着连连摆手说不要不要，撇下拿着开袋鸭蛋的爷爷不知所措。一碗粥吃完，爷爷又端来锅小心翼翼地问我要不要再吃一碗。放假刚回家的时候我很乐意再吃一碗，因为这样的粥在学校对我而言从来都是奢望，而呆在家的时间久了，我便厌倦了，我便不珍惜这再来一碗的机会。有时我捧着碗在院子里喝完粥，就把碗接点自来水放在池子边，然后空手进屋看看等着给我盛第二碗的爷爷，摆摆手示意不吃了。然后爷爷就会嘟囔着「就吃一碗啊」，默默把多出的粥盛了起来。我回到自己的小屋里摆弄手机电脑，爷爷一个人在池子边洗着碗。我总觉得，爷爷应该不会因为多洗我一个碗而觉得累吧，况且我和他一起吃早饭，他一定比独自在家的时候开心些吧。现在想想，我怎么如此不懂事！我多想再和爷爷一起坐在桌前，这次我来给爷爷剥一颗咸鸭蛋。</p>
<h2 id="劫">劫</h2>
<p>腊月二十三，北方的小年刚刚开始。我家是腊月二十四过小年，这一天是做大粑粑的日子，爸爸腊月二十五才放假，家里这天只有妈妈在准备东西。中午吃完饭，我打算上街把前阵子办的身份证领回来，于是先在家洗了个头。妈妈还在问我一会要不要骑电瓶车出门，向来都是步行去街上的我说不用骑车。在家里转了一圈没看见爷爷，于是原先准备出门前和爷爷打个招呼的我就径直去了邮政局。领到了新的身份证，走出邮政局，我犹豫要不要顺便在街上逛一逛，心想爷爷可能是出来买年货，这样说不定会碰见爷爷。慢悠悠走了一段，我觉得不会遇到，就回家了。走在回家的路上快要到家了，我突然接到爸爸的电话。电话那头爸爸急躁地说爷爷好像在街上邮政局附近让什么车子碰到了，责问我在哪呢、妈妈在哪呢。我莫名委屈，心想我怎么知道那些，你对我生气有什么用。我说我刚刚就从邮政局那回来，没看见有人给车撞到啊。挂了电话我还在生闷气，冷静下来考虑了一会决定再回街上去看一看。走了很远我都没看见什么异常，我只默默祈祷爷爷没出什么大事。</p>
<p>但是，我看到了远处救护车幽蓝色的光。腿有点无力，我跑了过去，看到许多村里的人，靠近救护车的地方妈妈哭红了脸。再看向救护车里，是爷爷躺在担架上。救护车底盘不低，再加上担架的高度，我在车下看不见爷爷的脸，只听见爷爷痛苦地呻吟着，那声音有气无力。我顿时不知所措，我知道爷爷一定正在经历着莫大的痛苦。救护车上的人喊着到底谁去谁不去（医院）赶快决定，车子要出发了。我问妈妈我要不要跟着去，妈妈用颤抖着声音阻止了我。我在路边看着妈妈和村里一个长辈上了车，救护车关上门无声地驶向县城。呆在路边的我还在回想刚才的呻吟声，我只听过爷爷有时候白天累了晚上睡觉时会哼哼，但这次的痛苦和平时完全是天差地别。目光搜寻着路边没有看见大片血迹，回想刚才看到的爷爷裤子鞋子上也没有什么明显的血迹，我只能祈祷爷爷没有危及生命的损伤。走在回家的路上我心里满是后悔，我为什么刚才不多逛一会，偏偏就在我回去的这段时间里爷爷让车子撞到了。爷爷这次上街怎么不和我打招呼？明明平时他出发前都会问我要不要买什么东西的，就算我每次都说没有什么要的，他都会次次问我的啊！如果这次他问了我一句，我一定会跟他一起出门的啊。毕竟快过年了、再加上自己也有要上街办的事，就算之前总是不愿意出门的我在这一天也想陪爷爷逛一次街啊！为什么……</p>
<p>晚上，爸爸和妈妈都在县医院。我从电话里知道了爷爷的伤势和事情的大体经过。是一辆三轮车撞的，骑车的人打了个喷嚏方向盘没把稳，蹭到了路边的爷爷，爷爷被带着摔倒了，鼻骨骨折，颧骨那边也伤了，整个脸都肿了。我不敢想象。我在心里咒骂着那个骑车的人，好好的年这下过不成了，爷爷这次还不知道要到何时才能痊愈，住院这一住我都不知道开学前还能不能再见到爷爷了。后来的几天我都迫切地想去县里看爷爷，但爸爸说因为疫情医院陪护的人要先有核酸检测证明，然后办陪护证才能留在病患旁边，不然就只能像他一样在医院护士不上班的时候才能进去陪爷爷。我在乡下，坐车去县城得一个小时，而医院七八点钟护士就来查证了。如此过了很多天，终于有一天我早晨五六点多起床，跟着那天恰好在家歇脚的堂哥的车去到了县医院。病房走廊口有个桌子拦着，平时不让没有证的人进去探视，真是有够脑瘫的，我心里这样骂着！走进病房，我看到了爷爷。爷爷脖子上带着脖套，脑袋僵硬地靠在枕头上，还在大声地呻吟着，我感觉整个病房里的人都在这样听着、看着这边。我看着爷爷鼻子附近的血痂和肿起的脸，真的好心疼。爷爷眼睛费力地睁着，但还是只能睁开一条缝，他盯着我看了许久，吃力地吐出几个字「哦！你们来了啊！」「你们忙得很不用急着来看我的」…… 我小心翼翼地握住爷爷的手，他的手还是那么温暖，我些许地安心了。爸爸说是因为刚才挪了一下，爷爷又疼得厉害了，所以才哼得那么大声。过了这么多天，爷爷还是疼成这样，抬手都要别人托着。我心里更恨那天的自己和骑车的人了！待了没过一会，爸爸就说要带我们走，护士要来了。我很生气，明明是看个病人，却要做得偷偷摸摸，但是这气却不知道往哪里撒，只能气鼓鼓地和爸爸说「我回去了！」，然后就踏上了回乡镇的公交车。</p>
<p>大年三十，家里只有爸妈姐姐和我，我们尽量表现得像过年的样子，祭祖、放鞭炮、吃年夜饭、看春晚，爸爸在快吃完饭的时候说等会十二点放完开门鞭炮就骑车去县医院陪爷爷，妈妈责备爸爸不注意自己身体、说等天亮再去又不是不行、有必要搞得那么着急吗、大半夜里骑车又不安全…… 两个人就这样吵起来，我说要和爸爸一起去，妈妈争吵的语气才舒缓了一点，爸爸也怕我熬不了夜才让步说等天亮再带我一起去。结果年夜熬到四点，我撑不住睡着了，等五点多爸爸要出发时又起不来床没去成。初几那些天我渐渐感觉开学在即，能和爷爷见面的机会不多了，搭着堂哥的车又去了两回医院，看到爷爷病情正在好转，肿消了，血痂脱落了，呻吟也少了。我觉得一切都会好起来的，今年暑假一定要陪爷爷逛街，和爷爷说话，给爷爷换手机……</p>
<p>正月十四，爷爷生日的前一天，爸爸把爷爷从医院弄回了家里，那天下午正下着雨，我还在和同学打王者，结果听到外面汽车的声音，爸爸从车上下来，我隐约听到了爷爷哼哼的声音。我那时还带着埋怨的心情想：爸爸怎么不让爷爷在医院里多住几天，这都没痊愈就要急着把他往家里弄，这样折腾来折腾去有什么好的，就算是明天过生日也不能这样瞎搞啊！爸爸和开车的人搀着爷爷，就那么把爷爷放到家里的床上，爷爷哼得更厉害了。我不情愿地放下了游戏，但是平复了一下还是很清楚：爷爷能痊愈比什么都重要。我收起手机在边上看了会爷爷，给爷爷脱了衣服、挪了挪身子。妈妈在一边看着，我想妈妈肯定是不乐意在家照顾爷爷的，爸爸这样把爷爷往家里弄，肯定只会让妈妈在家心情更差，说不定没几天就要吵一下，到那个时候我开学走了不在家，那他俩吵起来没完想想都心烦…… </p>
<p>后来有几天天气好，爸爸把爷爷搀到院子里让他坐着晒晒太阳，我觉得这样在家也还挺好的，爷爷在医院的时候肯定是没机会晒太阳的，这么做也许爷爷会好得更快。开学前的那些天，爸爸每顿把饭盛好，把爷爷扶着在床上坐起来，自己坐在床沿给爷爷喂饭，晚上也陪在爷爷边上。爷爷看起来也好了许多，吃完饭有的时候看见我还和我说几句。虽然还是能听到爷爷哼哼的声音，但每次经过爷爷床边都能看见这样一个活生生的人心里还是会好很多。</p>
<p>3 月 5 号，我收拾好了行李准备出发，那天也下着雨。我离开前看到爷爷躺在床上闭着眼，就没好叫醒他。爸爸在床边跟他交待，我和妈妈坐车离开了。我在车上的时候还在想一切都会好起来的，今年暑假一定要陪爷爷逛街，和爷爷说话……</p>
<p>3 月 27 号，我和爸妈通了电话，我询问爷爷身体怎么样了，他们说爷爷已经能自己活动了，爸爸也开始上班了，每天晚上回来。我感觉到了爸爸的开心。我觉得爷爷能渡过这个劫难真是不容易。挂断电话，我很舒心。</p>
<p>3 月 31 号上午十一点，我收到了姐姐的 QQ 消息「爷爷去世了 爸爸妈妈没跟你说 我感觉还是跟你说好了 瞒着你才不好」。</p>
<p>4 月的第一个周末我从爸爸的电话中得知，我 27 号给他们打完电话之后一天，晚上他和妈妈都在家，爷爷说他要洗澡，再三说他身体可以了，不用人帮忙的。爸爸就听了，出门去办了个事，结果回来发现爷爷歪倒在澡盆边失去了意识。爸爸把爷爷弄醒时，爷爷已经不怎么清醒了，但还勉强说了几句话，爸爸把爷爷送到床上躺着。后来村里人说什么魂魄之类的迷信的话，爸爸便没有把爷爷送去医院。就这样，爷爷在床上没有意识地躺了两天，在我姐给我发消息的前一天晚上九点离开了。当我听到爸爸说那些迷信的话时，我心里生气极了，要是那个时候爸爸能老老实实把爷爷送去医院…… 我在电话里多想埋怨爸爸几句，为什么偏要听信那种不着边际的话，也许那个时候还能抢救回来的。但是我再说什么都没有用了，更何况平时家里就爸爸对爷爷最上心了。</p>
<h2 id="梦">梦</h2>
<details><summary><strong>其一</strong></summary><br />

<p>爷爷病了，第一天爷爷看起来还正常，还能和爸爸、我说话。第二天上午爸爸带爷爷出去看病。后来爷爷躺在床上病得厉害了，身体很热。爸爸拿了一张纸盖在爷爷额头上，又拿了一小片蓝色贴纸贴在拇指指甲盖上，用拇指按着纸片，我看见贴纸上写着「同意火葬」。爷爷还在哼哼。火葬的时候，爷爷还睁着眼睛，那双眼睛很浑浊，像黄土的颜色，他说着他好冷要被子。</p>
<p>晚上躺在床上闭着眼睛，突然想起早晨的梦和爷爷，心里燃起一股无名之火，好像找个沙包，把那个沙包当成自己狠狠的揍一顿！为什么那么多事以前有机会做的时候不去做，现在来不及了做不了了才后悔。</p>
</details><br />

<details><summary><strong>其二</strong></summary><br />

<p>我在县城上学，爷爷一个人在乡下，爸爸骑着自行车带我到乡镇新大桥边上买东西，那个地名爸爸说出来的时候让我感觉以为是腊月二十三我接到爸爸电话的地方，但实际去了发现是个跟乡镇新大桥差不多的地方。骑在自行车上的时候，我变成了另一个人，我是坐在同学的自行车上，我坐在上面只感觉很高，特别高，我和同学和自行车感觉都被拉长了，像竹节虫那种感觉，同学在给我说什么一篇他自己写的网络文章还是什么，我猜测他是想让我说点什么。下车的时候，我又变回了之前那个自己，那里挺多摆小摊的，爸爸说这里的东西说不定有便宜又好的，让我也看看，不要瞧不上。我下了自行车看到都是卖水果的。挨着桥头的第一家在叫卖热带水果，好像都是那种好货、稀罕货，我看了会但是没买。朝远离桥头的方向走了一截，看到一家店爸爸正在里面买东西，这个店只有几平米的感觉，四四方方，很干净，店主竟然是爷爷。爷爷一边看书一边卖水果，他说话不清楚，像嘴里含着东西，在梦里是生了什么病正快要痊愈的时候。爸爸在买菠萝，他和爷爷在切菠萝，那个菠萝的皮不是我们一般看到的那种，而是皮的颜色和果肉一样，长出来一个一个须，爸爸去皮的动作有的时候是在剥皮、有的时候是在切。我有点奇怪。爸爸很赶时间的样子，最后一块直接拿走了爷爷摆在那现成的剥好了的。要走的时候，爷爷说他要跟镇上开黄包车的人说说，让他们带他去我那里，他给我送吃的水果。爸爸说着拒绝的话，大意是爷爷年纪大了不要跑远路。爷爷那个店里还有煮饭的锅一同放在水果上，爸爸帮爷爷把饭用家里那种白色塑料平勺盛出来放在边上哪……</p>
</details>

<hr>
<p>这一阵子，我时常想起爷爷，想起和爷爷在一起的那些点滴。曾经我对爷爷的讨厌，变成了现在加倍的悔恨，像一把把利刃插在心头。回想起连面容都已经被我遗忘的姑姑，我十分害怕爷爷也会被我遗忘。我翻出屈指可数的几张爷爷的照片，时常聊以怀念。每当想起和爷爷在一起的事情，我都会立马用纸笔或手机记录下来。就算是做梦梦见爷爷，我也会在醒过来后立马打开手机把这些梦境记录下来，生怕遗忘了分毫。</p>
<p>爷爷在医院的时候，我还在想：等爷爷身体好了，就让爸爸带着爷爷再好好逛逛县城吧，爷爷好像挺喜欢逛街的。年纪渐长，爷爷从乡镇再坐颠簸的公交车去城里也不太方便，现在这个情况就借此机会在县城逛逛吧。那天和父母通电话知道爷爷身体渐好的时候，我在想以后回家再见到爷爷，一定要加倍珍惜这些时光，一定要把自己心里想做的事都做了，不留遗憾。谁曾想…… 曾经没有做成的事以后也再无机会，珍惜眼前人才是永恒的道理。</p>
<p>爸妈都和我说，爷爷到了这个年纪，走了也是无可奈何的事，叫我别太伤心。但是，我总觉得如果那晚爷爷失去意识的时候我能在他身边、握住他的手叫一声爷爷；如果我开学前和爷爷说一句「您在家好好养身体，暑假我陪您逛街」这样的话、给爷爷留个念想；如果我那天在街上多逛几分钟、等到和爷爷相遇的机会；如果我那年暑假没有和爷爷怄气、多和爷爷增进感情，也许一切都会不一样。我不相信爷爷舍得离开，他一定也想再挽起我的手，再走一遍新街、老街。</p>
<p>……</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[猎户座 S10 5G 更新 Android 11 / Magisk / LSPosed 记录]]></title>
        <id>https://blog.monsterx.cn/tech/flash-magisk-latest-4-sumsung-s10-5-g-exynos/</id>
        <link href="https://blog.monsterx.cn/tech/flash-magisk-latest-4-sumsung-s10-5-g-exynos/"/>
        <updated>2021-02-03T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>最近 <a href="https://github.com/ElderDrivers/EdXposed">@ElderDrivers/EdXposed</a> 的新分支 <a href="https://github.com/LSPosed/LSPosed">@LSPosed/LSPosed</a> 进入大众视野，听说修复了 EdXposed 随机重启的 Bug。不知道手头的 Sumsung S10 5G (Exynos 9820) 莫名其妙重启是不是相关问题，咱得先试试 LSPosed 才知道。为了在不支持直接升级 Magisk 的《<a href="http://aurorarom.cn/archives/450.html">AuroraROM Sumsung S10E/S10/S10+/5G G97XX-9820 - V17.0 Android-Q-TJA</a>》上使用 LSPosed，我需要自行集齐 Magisk v21+、Riru v23+。于是折腾了一下三星的刷机，本文介绍自用三星 S10 5G 的 Android 11 升级、Magisk in Recovery 安装、LSPosed 使用等。</p>
<p>Android 11 的升级十分简单，刷最新的官方固件就成了。LSPosed 的安装只要解决了 Magisk 最新版本的需求也是小菜一碟。AuroraROM 不能直接在 Magisk Manager 中升级 Magisk，否则会无法开机，这一项只好自行解决。</p>
<p>Magisk 作者 <a href="https://github.com/topjohnwu">@topjohnwu</a> 撰写了完整的安装指南在 <a href="https://topjohnwu.github.io/Magisk/install.html">这里</a>，包含了三星机型和华为机型的说明。以此文为主要参考资料进行尝试（我顺便翻译了一份简体中文的版本放在 <a href="https://github.com/monsterxcn/myBlog/wiki/Magisk-Install-zh_CN">Magisk Install zh_CN - @monsterxcn/myBlog Wiki</a>。还有一篇 XDA 论坛的参考文章是用来解决 Bootloader 解锁后开机警告信息的，《<a href="https://forum.xda-developers.com/t/boot-remove-boot-warning-all-exynos-devices-after-root-tutorial-14th-december-2020.4202627/">[BOOT] Remove Boot Warning - All Exynos Devices - After Root - Tutorial - 14th December 2020 - XDA Developers Forums</a>》。</p>
<blockquote>
<p>YOU are choosing to make these modifications, and if you point the finger at me for messing up your device, I will laugh at you.</p>
</blockquote>
<h2 id="准备">准备</h2>
<p><strong>重要的资料务必先备份</strong>，如联系人、短信、相片、下载等。</p>
<p>我手上这台机器是韩版使用猎户座 Exynos 9820 的 Sumsung Galaxy S10 5G，正在使用的 ROM 是 AuroraROM Sumsung G97XX-9820 v17.0，进入 Download 模式后部分输出如下：</p>
<pre><code>PRODUCT NAME: SM-G977N
CURRENT BINARY: Custom(0x30e)
KG STATE: Checking
FRP LOCK: OFF
OEM LOCK: OFF(U)
Secure Download: Enabled
CARRIER_ID: KTC
WARRANTY VOID: 1 (0x0400)
RP SWREV: B:4 K:4 S:4
</code></pre>
<blockquote>
<p>如果你之前曾刷过 AuroraROM 等定制 ROM，那么一般来说 Bootloader OEM 已处于解锁状态。存在刷入官方固件后锁定状态改变的情况，具体要如何确检查锁定状态，可以将手机关机按住「下载模式组合键」连接电脑进入 Download 模式查看。</p>
</blockquote>
<p>请留意设备的各项锁定状态，不过刷回官方固件的话应该都没什么问题。接下来准备此次刷机需要的软件和固件：</p>
<ul>
<li><a href="https://developer.samsung.com/mobile/android-usb-driver.html">Android USB Driver for Windows - Sumsung Developers</a>，不要连接手机提前安装三星驱动</li>
<li><a href="https://developer.android.com/studio/command-line/adb">Android Debug Bridge</a>，参照《<a href="https://wiki.lineageos.org/adb_fastboot_guide.html#installing-adb-and-fastboot">Using ADB and fastboot - Lineage Wiki</a>》提前安装</li>
<li><a href="https://forum.xda-developers.com/t/tool-frija-samsung-firmware-downloader-checker.3910594/">Frija</a>，查找并下载官方最新固件包</li>
<li><a href="https://odindownload.com/Samsung-Odin/">Sumsung Odin</a>，三星专用刷机软件</li>
<li><a href="https://github.com/topjohnwu/Magisk/releases">Magisk Manager APK</a>（Magisk Manager 与 Magisk 一同发布），修补镜像以安装 Magisk in Recovery</li>
<li><a href="https://github.com/mcmilk/7-Zip-zstd">@mcmilk/7-Zip-zstd</a>，解压 BL 固件以移除 Bootloader 解锁警告</li>
</ul>
<h2 id="刷入官方固件">刷入官方固件</h2>
<p>在三星设备上安装 Magisk 需要首先 <strong>删除所有启动镜像修改</strong>（boot image mods），由于 AuroraROM 已经预置 Root，所以需要用原厂镜像重新刷机。</p>
<p>这里用 Frija 查找并下载固件。使用 Frija 前需要安装 <a href="https://www.microsoft.com/zh-CN/download/details.aspx?id=29">Microsoft Visual C++ 2008 Redistributable Package (x86)</a> 和 <a href="https://www.microsoft.com/zh-CN/download/details.aspx?id=5555">Microsoft Visual C++ 2010 Redistributable Package (x86)</a>。如果下载时卡在「Checking CRC32」可以尝试在 Settings 中关闭 CRC Check，下载完毕后另寻方式校验文件。</p>
<pre><code>Model: SM-G977N    CSC: KTC    Method: Auto
Version: G977NKSU4EUA4/G977NOKR4EUA4/G977NKOU4EUA4
Size: 5194 MB
OS: R(Android 11)
Filename: SM-G977N_4_20210120142634_acqegd7bb2_fac.zip.enc4
</code></pre>
<blockquote>
<p>如果 Frija 实在无法使用，可以尝试 <a href="https://github.com/nlscc/samloader">@nlscc/samloader</a>。网站 <a href="https://www.sammobile.com/samsung/galaxy-s10-5g/firmware/#SM-G977N">SamMobile</a> 和 <a href="https://samfw.com/firmware/SM-G977N">SamFw</a> 也提供三星固件查找下载服务。</p>
</blockquote>
<p>上方用 Frija 查找到的固件 <code>G977NKSU4EUA4</code> 为 Android 11 版本，是目前此系列机型的第一个 Android 11 版本推送，暂无国行 ROM 支持；Android 10 的最新固件型号应该为 <code>G977NKSU4DTJ8</code>。下面就用 Android 11 的第一份固件尝鲜。</p>
<p>将压缩包解压后得到 <code>AP</code> <code>BL</code> <code>CP</code> <code>CSC</code> <code>HOME_CSC</code> <code>USERDATA</code> 文件。<code>USERDATA</code> 不会用到。</p>
<p>将手机关机，按住 <code>Bixby</code>+<code>音量减</code> 插入数据线将手机连接至电脑，直至手机屏幕亮起松开按键，按一下音量加进入 Download 模式。</p>
<p>打开 Odin 软件，此时应该看到界面中提示「Added!」。接下来点击「AP」「BL」「CP」「CSC」依次选中对应的 <code>AP</code> <code>BL</code> <code>CP</code> <code>CSC</code> 文件。保证数据线连接可靠，点击「Start」开始刷入官方固件。</p>
<blockquote>
<p>如果点击 <code>AP</code> 包返回 Odin 后卡住，稍微多等一会就好了，这个包比较大。</p>
</blockquote>
<p><img src="https://rmt.dogedoge.com/fetch/tingle/storage/odin_fac.png?w=985&fmt=webp" alt="Odin 刷入官方固件"></p>
<p>接下来手机会重新启动。由于之前刷 AuroraROM 时已经解锁了 Bootloader，此时开机会弹出警告信息，略过即可，我们后面来干掉它。按 <code>音量减</code> <code>音量加</code> 键上下移动，依次选择「wipe data/factory reset」和「wipe cache partition」，最后「reboot system now」进入官方固件的系统。</p>
<h2 id="官方固件激活设置">官方固件激活设置</h2>
<p>紧接着上一步，在几分钟的等待之后进入了系统激活界面。这次激活的设置 <strong>不会影响后续使用</strong>，因为待会刷入 Magisk in Recovery 时所有设置都会被抹除。</p>
<p>从激活至进入系统设置启用开发者选项过程中如果始终未连接到网络，接下来你可能无法看见 OEM 解锁选项。可以在 <strong>无网络激活进入系统后</strong> 连接 WiFi，等待一会再进入开发者选项。OEM 解锁状态为 <strong>打开且灰色不可更改</strong> 时为正常状态，如果为可更改状态，那么可能需要另寻资料解锁 KG 锁（就是将系统时间调前 N 天解锁的那个玩意）。</p>
<p>在设置中启用开发者选项时可以顺手打开开发者选项中的 <strong>USB 调试</strong>，方便后续使用 ADB。</p>
<blockquote>
<p>我自己使用的方法是在激活时将手机 SIM 卡拔出，连接到笔记本正在使用的同一无线网络，设置 WiFi 使用笔记本上的代理。因为一旦联网，激活时需要连接谷歌和三星服务器验证一些信息。</p>
<ol>
<li>我的笔记本连接到了一个 <code>TP-LINK_233</code> 的 WiFi，且本地使用 Clash 在 <code>7890</code> 端口全局代理。</li>
<li>在 Clash 中打开「Allow LAN」选项，将鼠标放在该选项上可以看见「192.168.0.xxx  LAN」的字样</li>
<li>在手机上同样连接 <code>TP-LINK_233</code> 的 WiFi，并在「高级设置 - 代理服务器」中填入代理主机名 <code>192.168.0.xxx</code> 和代理服务器端口 <code>7890</code>。</li>
</ol>
</blockquote>
<h2 id="安装-magaisk-in-recovery">安装 Magaisk in Recovery</h2>
<p>将手机连接至电脑，使用 ADB 将预先下载好的 Magisk Manager APK 文件和刚才刷入的官方固件 <code>AP</code> 包传输至手机。注意在手机弹出页面中进行 USB 调试授权。</p>
<pre><code class="language-powershell">PS D:\Tools\platform-tools-r30.0.5&gt; .\adb --version
Version 30.0.5-6877874
PS D:\Tools\platform-tools-r30.0.5&gt; .\adb devices
* daemon not running; starting now at tcp:5037
* daemon started successfully
R3CM50460DD     unauthorized
PS D:\Tools\platform-tools-r30.0.5&gt; .\adb devices
List of devices attached
R3CM50460DD     device

PS D:\Tools\platform-tools-r30.0.5&gt; .\adb push D:\SumsungFirmwarePath\AP_G977NKSU4EUA4_xxxxxxxxxx.tar.md5 /sdcard/Download/
D:\SumsungFirmwarePath\AP_G977NKSU4EUA4_xxxxxxxxxx.tar.md5: 1 file pushed, 0 skipped. 35.3 MB/s (4825702590 bytes in 130.538s)
</code></pre>
<p>在手机上安装 Magisk Manager，进入应用查看手机信息：</p>
<p><img src="https://rmt.dogedoge.com/fetch/tingle/storage/magisk-manager.jpg?w=600&fmt=webp" alt="Magisk Manager 检查手机信息"></p>
<p>我正在用的这台三星启动镜像不包含 ramdisk，「SAR」状态为是，所以只能用 Magisk in Recovery 的方式刷入 Magisk。</p>
<p>接下来要手动修补镜像，点击「Magisk」卡片上的「安装」，确保「安装到 Recovery」被勾选，点击下一步「选择并修补一个文件」，选中刚才复制的官方固件 AP 包，等待 Magisk Manager 完成修补。修补后的文件在 <code>/Download</code> 文件夹下，将其用 ADB 推送至电脑。</p>
<pre><code class="language-powershell">PS D:\Tools\platform-tools-r30.0.5&gt; .\adb pull /sdcard/Download/magisk_patched_xxxxx.tar D:\SumsungFirmwarePath\
# [ 71%] /sdcard/Download/magisk_patched_xxxxx.tar
/sdcard/Download/magisk_patched_xxxxx.tar: 1 file pulled, 0 skipped. 43.3 MB/s (4891154944 bytes in 107.623s)
</code></pre>
<p>将手机关机再次进入 Download 模式，可以看到刷完官方固件后输出发生了一点变化：</p>
<pre><code>PRODUCT NAME: SM-G977N
CURRENT BINARY: Sumsung Official   # Custom(0x30e)
KG STATE: Checking
FRP LOCK: OFF
OEM LOCK: OFF(U)
Secure Download: Enabled
CARRIER_ID: KTC
WARRANTY VOID: 1 (0x0400)
RP SWREV: B:4 K:4 S:4
</code></pre>
<p>打开 Odin 软件，将修补后的 <code>magisk_patched_xxxxx.tar</code> 文件作为 <code>AP</code> 包与官方固件中的另外 <code>BL</code> <code>CP</code> <code>CSC</code> 三个文件一同再次刷入。注意此处需要在 Odin「Options」中将「Auto Reboot」关闭。</p>
<p>Odin 显示状态为绿色 PASS 后即可关闭 Odin 软件、将手机与电脑断开。</p>
<h2 id="进入-magisk-in-recovery">进入 Magisk in Recovery</h2>
<blockquote>
<p><strong>下面的操作请多查看几篇文章再操作</strong>。我反复尝试了很多次，但 Magisk Manager 都无法检测到 Magisk 环境，刷入了几个型号的固件也都无法解决。这应该是个极易出现的问题，不必着急，继续操作。</p>
</blockquote>
<p>紧接着上一步，我们将刷入修补 <code>AP</code> 完毕的手机断开连接，此时手机仍停留在 Download 模式。接下来应该需要一些连贯的操作以进入 Magisk in Recovery。第一步是长按 <code>电源</code>+<code>音量减</code> 大于 7 秒退出 Download 模式。接下来错误的下一步就可能导致各种问题。</p>
<p>一般来说，这一步应该是长按「恢复模式组合键」（对于 S10 5G 就是 <code>电源</code>+<code>Bixby</code>+<code>音量加</code>）至屏幕闪烁时立即松开所有按键。</p>
<p>如果时机不当或其他原因可能导致 <strong>手机陷入启动循环</strong>，这时要解救手机的方法应该是：在手机黑屏时按住「恢复模式组合键」，屏幕亮起后立即松开 <code>电源</code>+<code>Bixby</code> 只保留 <code>音量加</code>，直至进入真实的 Recovery 模式，然后擦除数据进行一次出厂重置。按下 <code>电源</code> 键确认出厂重置后如果没有其它动作，手机可能会再次陷入无限重启，所以理论上应该是需要在确认操作后立即按住「恢复模式组合键」，屏幕再次亮起时松开所有按键。</p>
<p>另一个最常见的问题就是进入系统后检测不到 Magisk（我认为此时 Magisk 应该已经成功安装，只是进入了无 Magisk 的系统）。原因应该就在于进入系统的操作失误。今天花了一整天不断地刷机、修补、重刷、激活，都没有搞明白自己到底是哪里的问题。晚上吃完饭我又尝试了几个小时，在一次重启尝试无果之后，我在 Windows ADB 上连接着 <strong>无 Magisk 的系统</strong> 调试，键入 <code>.\adb reboot recovery</code> 试图进入 Recovery 恢复出厂设置，接着手机重启像往常一样显示了 Bootloader 解锁的警告，然后 <del>我按下了电源键确认，</del> 等待了一会，手机成功进入了 Magisk in Recovery。在 Magisk Manager 中我终于看到了「当前 21.4(21400)」的字样。心情平复之后我将手机关机，按照官方说明按下「恢复模式组合键」，手机震动屏幕亮起时松开，手机也能正常进入 Magisk in Recovery。</p>
<p>最终我多次尝试发现：</p>
<ul>
<li>只要打开 USB 调试，在 Windows 命令行中键入 <code>.\adb reboot recovery</code> 并回车，等待手机开机即可，过程中不需要按下任何组合键。</li>
<li>如果没有笔记本可用，也可以先将手机关机，然后按下「恢复模式组合键」，在手机震动屏幕亮起时松开所有按键，等待手机开机即可。</li>
</ul>
<p><img src="https://rmt.dogedoge.com/fetch/tingle/storage/Screenshot_20210202-213410.jpg?w=600&fmt=webp" alt="成功进入 Magisk in Recovery"></p>
<h2 id="移除-bootloader-解锁警告">移除 Bootloader 解锁警告</h2>
<p>根据本文开头给出的 XDA 论坛 @Dante63 帖子，所有猎户座设备均可移除修改后 Bootloader 解锁的警告信息，方法为修改固件 <code>BL</code> 包中的图片再打包重新刷入。</p>
<ol>
<li>安装 7-Zip Zstandard Edition</li>
<li>在刷机时固件解压后的 <code>BL</code> 包上右键使用 7-Zip ZS 打开压缩包</li>
<li>解压其中的 <code>up_param.bin.lz4</code></li>
<li>在解压出来的 <code>up_param.bin.lz4</code> 包上右键使用 7-Zip ZS 打开压缩包</li>
<li>解压其中的 <code>up_param.bin</code></li>
</ol>
<p>接下来只需要用到这个压缩包中包中包 <code>up_param.bin</code>：</p>
<ol>
<li>使用 7-Zip ZS 打开压缩包 <code>up_param.bin</code></li>
<li>修改其中的 <code>logo.jpg</code> <code>booting_warning.jpg</code>：<ul>
<li>将 <code>booting_warning.jpg</code> 修改为全黑</li>
<li>显示原有 Logo：将 <code>logo.jpg</code> 重命名为 <code>svb_orange.jpg</code></li>
<li>展示自定义 Logo：修改 <code>logo.jpg</code> 为自定义 Logo 但不要调整大小和维度，复制一份名为 <code>svb_orange.jpg</code></li>
</ul>
</li>
<li>将修改后的图片拖进原 <code>up_param.bin</code> 文件保存修改</li>
<li>右键更新后的 <code>up_param.bin</code> 文件使用 7-Zip ZS 添加到压缩包，注意修改压缩格式为 <code>tar</code></li>
</ol>
<p>打开 Odin，将修改后的 <code>up_param.bin</code> tar 压缩包作为 <code>BL</code> 包 <strong>单独刷入</strong>。</p>
<details><summary>懒人必备</summary><br />


<p>我懒得修改，从旧的极光 ROM 包里找到了大佬修改好的 <code>up_param.bin</code> 文件，把它拖出来再单独压缩成 tar 包即可：</p>
<p><img src="https://rmt.dogedoge.com/fetch/tingle/storage/lazyme.png?w=985&fmt=webp" alt="AuroraROM 中已经修改好的文件"></p>
</details><br />


<p>这里我刷完自动重启后也成功进入 Magisk in Recovery，如果你不幸进入了没有 Magisk 的系统，可以参考上一章节重新进入。</p>
<h2 id="完工">完工</h2>
<p>在 Magisk Manager 中搜索「Riru」和「Riru - LSPosed」安装，再到 <a href="https://github.com/LSPosed/LSPosed">@LSPosed/LSPosed</a> 仓库的 <a href="https://github.com/LSPosed/LSPosed/releases">Releases</a> 中下载 LSPosed Manager 安装。</p>
<p>如果需要重启，直接在 Magisk Manager 中模块安装完成后点击重启按钮，貌似也可以不用任何组合键直接重新进入 Magisk in Recovery。如果失败了的话同样参考上上个章节重新进入，问题不大。</p>
<p>折腾完这些，手头的三星终于可以吃上 LSPosed 了，顺带还享受起了 Android 11 和 OneUI 3.0。官方固件自带谷歌全家桶，略显臃肿。</p>
<p><img src="https://rmt.dogedoge.com/fetch/tingle/storage/magisk-riru-lsposed.png?w=1280&fmt=webp" alt="Magisk Manager &amp; LSPosed Manager"></p>
<p><img src="https://rmt.dogedoge.com/fetch/tingle/storage/mobile-desktop.png?w=1280&fmt=webp" alt="软件信息 &amp; 主屏幕 &amp; 一加天气组件"></p>
<p>目前还没看到手上这个机型的国行 Android 11 ROM，所以暂时就继续用官方的了，这是一些我在用的感觉还蛮舒服的解决方案：</p>
<ul>
<li><p>三星支付因为 Magisk 修改无法使用</p>
<p>三星支付，用处不大，直接卸载（逃</p>
</li>
<li><p>国内软件的指纹支付不可用</p>
<p>在 Magisk Manager 中安装 Jason Eric 的「Riru - 指纹支付」系列插件</p>
</li>
<li><p>自带的天气组件定位不到我所在的村子位置</p>
<p>在 Magisk Manager 中安装 MarcAnt01 的「Oxy-ify」，将一加的天气组件安装上去</p>
</li>
<li><p>听腻了三星铃声想换一个</p>
<p>「Oxy-ify」可以顺带安装一加的铃声。Magisk Manager 中还有其他系统如 MIUI 的音效包</p>
</li>
</ul>
<blockquote>
<p>我还蛮喜欢一加 OnePlus tune 的调调的，嘿嘿🤣</p>
</blockquote>
<p>如果你对本文后续三星设备上安装 Magisk in Recovery 的步骤有任何建议欢迎留言，我只是将自己的操作记录了下来，仅供参考，未必适用于其他三星设备！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[年度 · 2020]]></title>
        <id>https://blog.monsterx.cn/life/2020-annual-summary/</id>
        <link href="https://blog.monsterx.cn/life/2020-annual-summary/"/>
        <updated>2021-01-20T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>年度总结的开头惯例是感慨一下「时间过的可真快啊」，2020 的确如此：上半年由于疫情，我直接在家过了一整个学期；下半年提前开学提前放假，18 周教学周周匆忙。想想自己的大学生活，不经意间已经过了一半有余！</p>
<h2 id="流水帐">流水帐</h2>
<p>2020 的寒假准备将博客的文章整理整理，然后开始学习数学、物理、电路。计划是将 2019 年 10 月去长春玩的最后一天的日志写出来。嗯…… 如你所见，到现在也没有写出来。寒假还没有开始的时候网络上就隐约有了疫情的消息，我怎么也不会想到这会导致春季学期只能在家上网课。网课期间接触了很多 RSS：一是用 RSSHub 的轮子写了个岛国动作片种子的订阅源，虽然内容不正经但却是我第一次正儿八经向开源项目 Pull Request；二是购入 Digital Ocean 新加坡的机器折腾了 Aria2 配合 RSS 订阅自动下载到 OneDrive，在家配合流量用不完的 Dler 自动同步网盘里的下载，真是十分伤身体。顺便也在这台服务器上搭建了 Visual Studio Code 等，尝试了一些新鲜玩意。上半年的学习，栽了模拟电子技术，但电机学那么复杂的课程我也在张老师的帮助下过了，甚是感激。</p>
<p>2020 的暑假在折腾博客，眼馋 <a href="https://github.com/spencerwooo">@spencerwooo</a> 大佬博客的样式，外加厌倦了版本停滞、一成不变的 Typecho 后台（那阵子总有外国的垃圾评论），于是将延续两年的 Typecho 换成了 Gridsome，正式转战 Gridsome 之前也尝试了一阵子 Hexo。静态博客的感觉嘛，虽然没有了后台直接管理，但部署到各个白嫖的节点上都很方便，评论系统的选择也更加多样。说到评论系统，8 月也在 Artalk 上花了一些心思，将其部分样式修改后用在了新生的 Gridsome 博客里。写了一篇 Artalk 部署的文章，感觉被不少静态博客的朋友看爆。计划着下半年返校了每月迁移几篇旧文章，结果下半年返校后忙的要死、一篇文章也没再迁移。博客也变得死寂，有空在 Artalk 评论管理中看到新评论都是稀罕事。</p>
<p>下半年虽说返校，但明面上都是封校的状态。看到别人返校后都充满自由气息的时候我就十分羡慕，虽然自己是个宅男不需要出门。到达哈尔滨后，拖着行李的我在校外和几个室友吃了顿火锅，然后才回到封锁的学校，有些滑稽呢。下学期的课不仅难，而且还有诸多实验：工程实践、数字电路实验、自动控制原理实验、电力电子技术实验、电力拖动实验、电力系统分析实验。在实验环节我尽量先看看书，争取做实验的时候不做躺狗。虽然有的实验还是无法避免成为躺狗，但自己动起手来而不是像个小丑一样坐在一边的时候感觉真的很好。这学期提前考试的操作实在「可以」，原本考试的事情截止在 6 日，但是 12 月 30 日才通知截止日期提前到 3 日了。我：复习可不就指着那几天了吗？！</p>
<p>下半年回到学校之后虽说是「封校」，但还是和室友们出去吃了好几顿饭。在某家店吃铁锅炖的时候还因为铁锅过热，差点把人炸没了。那家店长事后过来就让区区一个服务员阿姨处理，阿姨扯这扯那的还收了饭钱，说什么下次再来给优惠…… 但凡我要是脾气爆点…… 还实在是很不好的回忆。宝贝寝室长当时还庆幸自己没被伤着，出店后没走一会儿就在路边吐了起来。10 月底吧一个室友发烧了，在医院隔离了两个星期，紧接着 11 月的时候宿舍楼里莫名有了水痘疫情，寝室长没扛住在校医院隔离了好几周。水痘听说不能碰水，所以寝室长几周没洗澡，回寝室后时不时就会被大家用来开玩笑。下半年实在是多灾多难。</p>
<h2 id="第一次坐飞机">第一次坐飞机</h2>
<p>4 号凌晨两点我第一次动身前往哈尔滨太平机场，一个人打了辆出租车，被司机带到高速上遛了一圈，半个多小时就把我送到了机场，相应的车费也贵了许多。误打误撞一进机场就看到了机器，我便把机票取了出来。这个时候才三点多，我背着包不知道该去哪里，最后找了个地方靠着眯着了。5 点的时候睁眼看到很多人在行李托运的地方排队，我看那人多就傻乎乎地跟在后面排队，等到了我的时候服务人员客客气气问我要办理什么业务，我支支吾吾说了句「啊，不用托运的话原来就不用在这办理啊」…… 行李过安检的时候我忘了我还有一瓶酸奶，我不想站在那咕嘟咕嘟喝酸奶，于是就让安检人员把它丢了…… 经济舱坐起来和硬座没什么区别，飞机的窗户比我想象中的小很多。</p>
<p>总之，坐飞机的体验很一般（我究竟在期待些什么啊</p>
<blockquote>
<p>这好像已经是 2021 年的事了耶！不过在年度 2020 里写应该也 Daijōbu</p>
</blockquote>
<h2 id="总结">总结</h2>
<p>这一年嘛，尤其下半年在学习上花的精力比以前多了许多，我呀终于回想起自己学生的本分。虽然成绩还是没什么起色，但是会慢慢好起来的吧？做数电卷子的时候感觉自己上大学以来从来没有将一张卷子做得如此透彻，甚至自信地将两道设计题留空也不担心会挂科。哦，当然啦，我的确是不会写那两道题。结果成绩出来的时候发现险些不及格：这课居然最终评分全看这一张卷子！这学期的课程基本让我清楚了电气工程以后该干啥，但我还是拿不准考研和工作这两个方向，总觉得像我这种废物要是考上了研究生是对其他努力的人的不公。</p>
<p>今年我成功戒掉了王者荣耀等浪费时间浪费金钱的游戏。以前总是会和几个朋友一起玩，玩的虽然菜，但是和大家连麦聊天真的很开心。但是现在感觉不一样了，每天都累得要死，纵使看见室友在峡谷大杀四方我也只想睡觉。游戏上省下来的时间除了贡献给睡眠之外，还贡献给了二次元。10 月番追了好几部，《总之就是非常可爱》虽然也算是恋爱番，但是却没有那么吸引我了，柠檬吃多了果然还是会免疫。还是《在魔王城说晚安》这种搞笑的对胃。下半年一直在期待的巨人最终季一直拖到了年末，岂可修！</p>
<blockquote>
<p>哔哩哔哩追番的年度报告也出来了，据统计这一年有 137 天我在 B 站看番，其中 7 月份看的时间比较多，喜欢在下午看番，曾最晚在 02:27 看《在魔王城说晚安》。</p>
<p><img src="https://rmt.dogedoge.com/fetch/tingle/storage/2020bgm.png?w=1280&fmt=webp" alt="我的 2020 追番报告"></p>
</blockquote>
<p>如果 Verilog 也算进我的编程技能树的话，今年编程能力也有提升呢！（逃…… 今年在数电课上学到了 Verilog，感觉又是一门学过 C 语言就很好懂的语言。由于课上没怎么听，我不怎么会用 Verilog 写按键消抖和多数码管扫描，实验要用到的时候都尽可能绕过这个操作。今年还学会用 MATLAB 了：依旧借着 C 语言的底子（<code>for</code> 循环而已），我写了一个简陋的计算电机拖动项目设计数据的脚本，即便简陋，在直流他励电动机分级启动的设计上它还是帮我节省了很多时间（也多亏了写这个脚本，我熟悉了设计过程）。电力系统分析的大作业是用 Matpower 做的，用矩阵定义电力系统的电压、阻抗等数据，然后进行潮流计算。Simulink 也是今年新接触的，电力电子技术、自动控制原理、电机拖动基础都用它搭仿真模型，找资料搭模型一时爽，分析模型写报告就复杂起来了。</p>
<h2 id="期待">期待</h2>
<ul>
<li>2021 继续学习电气工程的知识，「工程师」这名头外行人听起来应该也还蛮酷的</li>
<li>追番！</li>
<li>认识一些新的有意思的博客主</li>
<li>写作嘛不想定什么一年几篇的目标，随时写点对自己而言有意义的东西就好了</li>
<li>在 Python MATLAB 上花点功夫，做点小玩意</li>
<li>有机会的话想将 HEU RSS 订阅源用 RSSHub 再完善一下</li>
</ul>
<p>今年的年度总结好像有些敷衍呢。最近也看了好几篇年度总结，感觉太怀旧也不好。往年的总结通篇流水帐，夹杂着抒情，除了能给八十岁健忘的自己带来稍微多一点的回忆之外，好像没什么特别之处了。今年索性压缩了流水帐的篇幅，尽管现在看来还得靠流水帐撑场面。也许几年后我多给老板交些工作总结，自己博客的年度总结风格也会跟着严肃起来。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[手帐 · 封锁之下]]></title>
        <id>https://blog.monsterx.cn/life/heu-in-amazing-walls/</id>
        <link href="https://blog.monsterx.cn/life/heu-in-amazing-walls/"/>
        <updated>2020-09-30T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>本来 22 日打算就学校疫情防控下某一奇幻行为发表批评的声音，结果由于一些个人原因稿子写了一半放弃了。今天看到自己冷清的博客心里有点失落，索性将旧的手稿改写成一篇手帐。</p>
<h2 id="生活">生活</h2>
<p>开学接近一个月，我正逐渐习惯在学校尚未解封的情况下生活。</p>
<p>封校对我而言其实并没有什么太大的影响，网购的东西依旧能送到菜鸟驿站，衣食住行基本都有解决的办法。只不过点外卖变麻烦了、不能和朋友出校聚餐、看热门电影了。乐观点，这些封锁倒是让我省下了不少生活费，在学习上花的功夫也前所未有的多了（当然也不排除我想到毕业时的焦虑情绪影响）。一个月的时间，我需要准备因疫情延误的上学期期末考试，其中的后两个月备考同时还需要学麻烦的专业课程。室友说考研大概就是这种感觉吧，每天都要在崩溃边缘挣扎。于我而言倒也没有那么夸张，因为一些实在是难懂的专业选修课我干脆抛开了。我每天不用考虑吃什么、去哪里，早晨起床就去食堂喝一碗朴素的粥，接着在图书馆、教学楼找位置看书。上午结束了就再去食堂找个人少的窗口打点饭菜，狼吞虎咽吃完回寝室休息一会，又接着开始一下午的耕耘。晚饭也是和中午一样，但是会换个窗口换个口味。晚上接着去白天学习的位置，9 点多回寝室唠唠嗑、看看稀奇古怪的应用推送，洗脚睡觉！当然这是最理想的情况，实际我还有一些时间花在了睡觉和发呆上。</p>
<p>前两周我坚持的还算可以，后两周由于开始正式上课了，复习备考的时间几乎都被压榨干净，整个人也疲倦了许多。</p>
<p>周一一整天都是补上疫情耽误的工程实践课，三个周一分别练习车削、特种加工、电子工艺。车削车床简直是我的噩梦，蜗杆正转还是反转我根本记不住，在老师的手把手指导下我成功表演了正反转不分、瞎旋进旋出，车了一个端面后人就宕机了。还好这是两人一组用一个车床，我队友一个人就车了一个全组最光滑的作品。特种加工倒还蛮简单，画一个平面图用 3B 代码模拟切割测试通过即可，旁边的人在画守望先锋里的武器，我想了半天也没想出来能画个什么，最后就对着哔哩哔哩的标志画了一个小电视的轮廓交上去。3B 代码写起来十分无脑，不需要什么逻辑处理，就是简单的算几个参数交给机器划线，无敌的我完成了自己的还帮同桌写了一份，成就感满满。电子工艺就是烙铁实践，时隔两年我再次拿起烙铁，心里五味杂陈。曾经还许诺自己做个科创大佬，现在啥也不是，连烙铁用起来都技不如人。</p>
<p>周二是从早上八点上到晚上八点的辛苦日，上午工程电磁场原理课讲偏工程实际的电磁场的一切理论，是咱学校电气工程的基础课。接下来新时代习思想课，最先只有黑龙江省和北京上海开设的思政课程。上午的课程约莫十二点结束，一个半小时后下午的课开始了。电力电子技术，是模电数电大类之外的电子技术理论，才开始讲六大电力电子器件，接下来会讲交流与直流四大类基本变换：整流、逆变、斩波、调压。电力系统分析，电气工程专业课，分析电力系统的理论目前正在讲电力系统的数学模型、潮流计算。「潮流」是电力系统的专业名词之一，「手工算潮流」实际是讲给出某些值求解这个电力系统中任意一点的运行状态。这些课程听起来都蛮有专业的感觉，虽然不像数学物理理论那样抽象，但实际用到的都是这些基础知识（尤指电路），公式不好记且需要理解推导过程。电气工程这一体系在这些课程的讲解下逐渐现出轮廓，我深深感觉到高等数学、物理、电路基础知识在更加高深的理论中重要性。这些专业课普遍需要复变、电路的知识来支撑，各种数学模型、等效电路如果没有这些基础理解起来十分难懂。</p>
<p>周三周四周五除了上面的课还有数字电子技术和自动控制原理。数电还算可以听懂，正在讲一些逻辑电路。数电老师十分关心坐在后排学生的听课体验，课前经常在教室后面和同学唠嗑，鼓励大家往前坐。这好像是我第一次注意到咱学校有这样的老师。自动控制原理，咱学校的考研课，用数学模型分析计算传统控制系统的性能。刚听起来这段时间和我上学期选修的数字信号处理有点相同的感觉，用数学函数表示输入信号输出信号，讲课过程中傅里叶变换、拉普拉斯变换张口就来，听了几节课我就完全蒙了。</p>
<p>专业选修课已经开课的只有可编程控制器，讲的是用只有中国地区还在用的西门子 S7-200/300 控制器做小项目比如物块分拣、电梯什么的，实验课的占比很大，很多课都像这样不仅在理论上要求掌握，在动手实验的能力要求上也没有丢下。简单来说就是水课没得了。</p>
<h2 id="读书">读书</h2>
<p>繁重的学习任务让我这个月牺牲了很多娱乐摸鱼的时间。但从这个学期开始，我读书了！</p>
<p>中旬我在校图书馆借了一本《三体》，这是我一直想读的书。高三时就买了全套纸质书，还有银河帝国的全套，信誓旦旦计划要在高考之后好好读，结果后来时间全花在了追剧看电影上，三体也只看了第一部汪淼玩「三体」游戏的那几章。开学来打算将家里的书带过来，奈何行李太重了，小说就被我抛弃了。在图书馆借完书当天晚上我找了个座位看三体，越看越着迷，一直到九十点才回寝，旁边的数字信号处理书一页都没翻。三体第一部按我的总结是以纳米材料科学家汪淼的视角讲述了叶文洁在文革前后在红岸基地（和后来的第二红岸基地）与三体人建立联系并成立了地球三体组织、准备迎接三体舰队的故事。</p>
<p>大部分时候，我对看书其实并不太感兴趣。小的时候喜欢看那些传说神话之类，读起来也许潜移默化中改变了自己的价值观、但最主要的还是感觉故事情节有趣。后来我也只是在《少年博览》《科学 FANS》中找故事读，没怎么读过文学著作。这大概就是为啥现在的我品味素质修养都不太高的原因吧。初三读过《斗罗大陆》第一部，高中读了一点点《雪中悍刀行》，这些书我觉得都不是拿得上台面的，让老师看见了指定要被没收而且批评。而《三体》作为屡屡获奖的科幻文学作品，其中的物理知识给人一种「亦真亦幻」的感觉，就算让老师逮着了应该情节也不能算太严重。读完第一部三体之后我接着借来了李淼的《〈三体〉中的物理学》给自己深度扫盲，借刘慈欣为李淼作序《比科幻更神奇的科学》中的一句话为这本书做总结：</p>
<blockquote>
<p>他（李淼）并没有像一般的读者和网友一样，专注于挑小说中的硬伤（在这方面他无疑是最有资格的），而是以《三体》中的科幻内容作为引子和起点，描绘了一幅现代物理学和宇宙学的宏伟图景。</p>
</blockquote>
<p>这本科普我目前才读了一半，我对后面李淼「从物理学的角度」探讨「自由意志」的命题十分期待。我越发觉得数学、物理基础学科是如此的神圣，只有天才才能掌握吧。</p>
<p>借到三体第一部之后一天我把所有的复习工作都推了，一心读三体，驰骋在浩瀚宇宙中希望有一天自己也能到达那里。第一部读完之后我立刻去借了第二部并且以更甚的热情读完了，罗辑的那句「我对三体世界说话」真是太震撼了！最后一章，人类面对比自己强大无数倍的三体世界几乎没有丝毫战胜的希望，唯一的面壁人罗辑作为最后希望也失去了人类的信任，但即使这样被人类驱逐的罗辑还是扭转了局势建立「威慑」。这一部中刘大对宇宙文明法则的思考我觉得堪比阿西莫夫机器人三大定律，太神了！如我在众多日漫中力推《进击的巨人》一样，《三体》也将是我在科幻文学的前排推荐。</p>
<p>第三部在图书馆没有借到，我便借了另外一些书，比如《冰与火之歌》《梦的解析》《黄衣王》。《冰与火之歌》是 HBO 权游的原著，《梦的解析》大概是每个心理学学者必读书籍，《黄衣王》大概是和「克苏鲁」一个范畴的小说。其实还打算借猫腻的《庆余年》和紫金陈的《长夜难明》，但这两本都借不到，估计是改编电视剧热播带动的吧。</p>
<p>我真恨，为什么前两年花了那么多时间在看无意义的视频上？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为 Gridsome 添加 Artalk 自托管评论系统]]></title>
        <id>https://blog.monsterx.cn/code/use-self-hosted-comment-system-in-gridsome/</id>
        <link href="https://blog.monsterx.cn/code/use-self-hosted-comment-system-in-gridsome/"/>
        <updated>2020-08-21T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>本文介绍在 Gridsome 博客中启用 Artalk 自托管评论系统的方法。欢迎尝试这款小众的、漂亮的评论系统！</p>
<p>刚开这个小站时打算一劳永逸吃上 Disqus 这块香饽饽，结果没两天我的宝贝室友就跟我说：你站怎么没法评论啊？我深思熟虑之后决定还是不用 Disqus 了。换 Gitalk？不行不行，Gitalk 虽好但是每一个新站点都需要 GitHub 账号授权一次，而且国内访问也体验不佳。Valine 之流我不太喜欢，其他的评论系统我都不甚了解。那该何去何从呢？</p>
<h2 id="选择-artalk-的理由">选择 Artalk 的理由</h2>
<p>由于水平不足，我是没法自己写一个评论系统的，于是我决定在友链 <a href="https://qwqaq.com/">@QWQAQ</a> 和 <a href="https://www.ouorz.com/">@TonyHe</a> 两位大佬的两个评论系统里选一个，要知道缝合代码、借用轮子这种事我最擅长了。那么是用 <a href="https://github.com/qwqcode/Artalk">@qwqcode/Artalk</a> 还是 <a href="https://github.com/HelipengTony/nexment">@HelipengTony/nexment</a> 呢？</p>
<p>外行人看热闹，我以一个前端菜鸟的水平不足以在架构上对两个评论系统做出优劣比较，所以以下只是我个人选择的理由。</p>
<p>Nexment 是 <del>React.js 编写</del> 「计划全平台、全框架适配」的基于 LeanCloud 实现 Serverless 的评论系统，官方提供了 React.js 和 Vue.js 示例，有自己的文档（虽然 Tony 好像还没有写详细，但至少有一个站点在那）。官方示例站点 <a href="https://nexment-demo.ouorz.com/">Nextment for React Demo</a> / <a href="https://nexment-vue-demo.ouorz.com/">Nextment for Vue Demo</a>，我觉得新颖的点在弹窗显示多级评论上，在我逛的博客圈子里比较少见。部署的话需要提前配置 LeanCloud 的数据库，这让我停止了思考（我的数据库放在别人那里想想就不靠谱啊喂）。Nexment 诞生于最近一月，截至本文发布前最后一次提交在三天前，作者 TonyHe 感觉是个努力 Coding 的巨佬，毕竟即将出国留学了。</p>
<p>Artalk 是 TypeScript 编写的需要自行部署后端的「一款简洁有趣的自托管评论系统」，数据存放在 JSON 文件中，后续听说也计划增加 MySQL 的支持（我：那样听起来就不太简洁了呢）。需要自行搭建后端估计劝退了很多人，而且目前只支持 PHP 后端，README 里写的 Go、Node.js、Python 后端均迟迟未上线。官方给的示例只有几个 HTML，相当的「简洁」，基本都是在 HTML 引入 <code>Artalk.css</code> <code>Artalk.js</code> 后一些简单的配置。官方示例站点 <a href="https://artalk.js.org/">Artalk DEMO</a>，听说在这里可以观察到开发者立 Flag 现场。Artalk 诞生于 2018 年 10 月，截至本文发布前最后一次提交在今年 5 月，考虑到作者 QWQAQ 的学业繁忙，摸鱼也是可以理解的。</p>
<p>简单了解两个评论系统之后，再看自身的 Gridsome 平台，基于 Vue.js。怎么看我都应该选择 Nexment，但是我却选择了 Artalk。原因嘛，自然是图个简单。Artalk 之前就搭建了自己的后端使用过一段时间，官方搭配的滑稽表情包在别的评论系统一众阿鲁表情包、贴吧表情包中独树一帜。更重要的是 Artalk 的代码我能看懂一些，进行自定义修改很方便。Nexment 虽好，但是外观相比 Artalk 我还是更喜欢后者，弹窗多级评论显示对我来说也需求不高，要我看 React.js 项目代码更是劝退。</p>
<h2 id="对-artalk-的修改">对 Artalk 的修改</h2>
<p>Artalk 目前还没有支持夜间模式，原本的样式和本站也不太搭。于是我 Fork 了一份代码针对这两个问题进行修改。</p>
<p>夜间模式主要按照当前主题和部分 Disqus 的配色、样式进行调整。其实之前也尝试配过一个夜间模式，用在自己修改后的 Typecho 主题上，但是代码过于粗糙。我调整颜色的方法甚至是直接将原版压缩后的 <code>.css</code> 打开后按 <code>Ctrl</code> <code>F2</code> 全部替换！剩下的样式代码压缩后即使找工具美化也看的我云里雾里。这次直接克隆仓库安装依赖从源头编译，方便那不是一星半点！</p>
<p>到本文发布为止，我共进行了十余次提交，主要对以下这些地方进行了修改：</p>
<ul>
<li>夜间模式</li>
<li>小屏幕样式部分适配</li>
<li>评论显示效果嵌套层数自定义</li>
<li>控制台版权去除</li>
<li>「Power By Artalk」 调整</li>
<li>侧边栏通知中心细节调整</li>
</ul>
<p>夜间模式的配色均在 <a href="https://github.com/monsterxcn/Artalk/blob/master/src/css/_variables.less">_variables.less</a> 中定义，以 <code>--at-</code> 为前缀。GitHub 仓库地址 <a href="https://github.com/monsterxcn/Artalk">@monsterxcn/Artalk</a>，我搭了个示例站点 <a href="https://artalk.vercel.app">Artalk ♂</a>。我没有系统学过 CSS 写法，所以让本应简洁的代码变得不简洁了，希望各位多发挥才智、创作自己的二次开发版 Artalk！<del>今天发现评论区的 <code>&lt;pre&gt;</code> 代码块样式还存在问题，</del> 探索中 😣……</p>
<h2 id="在-gridsome-上调试">在 Gridsome 上调试</h2>
<p>刚使用 Gridsome 大约一周，对它的了解很少，Vue.js 水平连门都入不了。但是这样的我还是花了几个小时将 Artalk 成功适配到了博客。中间踩了几个坑在这里提一下解决方法。</p>
<h3 id="安装-artalk">安装 Artalk</h3>
<p>Artalk 提供了 npm 包，所以可以直接在命令行安装</p>
<pre><code class="language-bash">npm install artalk --save
</code></pre>
<p>如果需要安装我修改之后的版本则需要在 <code>package.json</code> 中手动写入仓库地址：</p>
<pre><code class="language-diff">{
  &quot;name&quot;: &quot;gridsome-starter-blog&quot;,
  &quot;private&quot;: true,
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;gridsome build&quot;,
    &quot;develop&quot;: &quot;gridsome develop&quot;,
    &quot;explore&quot;: &quot;gridsome explore&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@gridsome/plugin-google-analytics&quot;: &quot;^0.1.0&quot;,
    &quot;@gridsome/remark-prismjs&quot;: &quot;^0.2.0&quot;,
    &quot;@gridsome/source-filesystem&quot;: &quot;^0.6.0&quot;,
    &quot;@gridsome/transformer-remark&quot;: &quot;^0.3.0&quot;,
-   &quot;gridsome&quot;: &quot;^0.7.0&quot;
+   &quot;gridsome&quot;: &quot;^0.7.0&quot;,
+   &quot;artalk&quot;: &quot;https://github.com/monsterxcn/Artalk.git&quot;,
  },
  &quot;devDependencies&quot;: {
    &quot;node-sass&quot;: &quot;^4.12.0&quot;,
    &quot;sass-loader&quot;: &quot;^8.0.0&quot;
  }
}
</code></pre>
<p>这里 L16 会直接引用我修改后的最新开发版，但是如果用于自动构建发布站点的 GitHub Actions 中使用了依赖缓存，则总是使用第一次执行工作流时安装的版本，无法获得后续更新。<del>为了解决这一问题，将 Git 链接修改为指定 commit 时刻的地址即可</del> 这好像也不可行。</p>
<h3 id="引入-artalkcss">引入 <code>Artalk.css</code></h3>
<p>接下来引用 <code>Artalk.css</code> 和 <code>Artalk.js</code>，建议单独新建 <code>ArtalkCards.vue</code> 文件存放 Artalk 评论组件的代码，只在该模板中引入 <code>Artalk.css</code> 即可。</p>
<pre><code class="language-javascript">import &#39;artalk/dist/Artalk.css&#39;
</code></pre>
<p>当前不必要的 <code>.css</code> 文件我们都让它在不得不引入时再加载。</p>
<h3 id="引入-artalkjs">引入 <code>Artalk.js</code></h3>
<p>最初引入 <code>Artalk.js</code> 时，我参考主题使用 DisqusJS 的方法在 <code>.vue</code> 模板文件的 <code>&lt;script&gt;</code> 标签中这样写：</p>
<pre><code class="language-javascript">import &#39;artalk/dist/Artalk.css&#39;
import Artalk from &#39;artalk&#39;

export default {

  // ...

  mounted() {
    // Initialize post comment by Artalk
    if (process.env.NODE_ENV === &#39;production&#39;) {
      var artalk = new Artalk({
        el: &#39;#artalkcomments&#39;,
        placeholder: &#39;说点什么 (づ￣ 3￣)づ&#39;,
        defaultAvatar: &#39;mp&#39;,
        // maxNest: 2,
        pageKey: &#39;https://blog.monsterx.cn/some-page/&#39;,
        serverUrl: &#39;https://lab.monsterx.cn/ArtalkServer&#39;,
        readMore: {
          pageSize: 15,
          autoLoad: true,
        },
      })
    }
  },
}
</code></pre>
<p><code>gridsome develop</code> 预览正常，但是发布时遇到「ReferenceError: window is not defined」，提示的报错信息都来自 <code>node_modules/artalk/dist/Artalk.js</code>，我以为是自己修改 Artalk 出的问题，于是又回去修改 Artalk 代码，将网上用来解决这个问题的几个方法都试了一遍依旧报错。正当我迷惑时，突然想到了 Gridsome 的源头 Vue.js 本身，于是我一拍脑袋在搜索时加了关键词 <code>gridsome</code>，这才发现原来和「Client API」有关。</p>
<p>几个参考链接《<a href="https://stackoverflow.com/questions/40707481/window-is-not-defined-in-vue-js-2">javascript - &#39;window&#39; is not defined in Vue.js 2 - Stack Overflow</a>》《<a href="https://github.com/gridsome/gridsome/issues/646">Failed to render / ReferenceError: window is not defined (vue2-leaflet) - issue #646 - GitHub @gridsome/gridsome</a>》《<a href="https://gridsome.org/docs/client-api/#isclient">Client API - Gridsome</a>》</p>
<p>虽然不知道这是个什么东西，但是大概说的是有些代码只能在客户端跑，服务端无法 <del>执行</del>「渲染」，比如 <code>window</code> 的操作。要说专业点，应该是关乎 S(erver) S(ide) R(ender)「服务器端渲染」的机制。根据上面第二个链接中 <a href="https://github.com/gridsome/gridsome/issues/646#issuecomment-578367659">IHIutch 的回答</a>，成功找到了解决方案：</p>
<pre><code class="language-diff">import &#39;artalk/dist/Artalk.css&#39;
-import Artalk from &#39;artalk&#39;

export default {

  // ...

  mounted() {
    // Initialize post comment by Artalk
    if (process.env.NODE_ENV === &#39;production&#39;) {
+     let Artalk = require(&#39;artalk&#39;)
      var artalk = new Artalk({
        el: &#39;#artalkcomments&#39;,
        placeholder: &#39;说点什么 (づ￣ 3￣)づ&#39;,
        defaultAvatar: &#39;mp&#39;,
        // maxNest: 2,
        pageKey: &#39;https://blog.monsterx.cn/some-page/&#39;,
        serverUrl: &#39;https://lab.mocurio.com/artalk/&#39;,
        readMore: {
          pageSize: 15,
          autoLoad: true,
        },
      })
    }
  },
}
</code></pre>
<p>L10 <code>process.env.NODE_ENV === &#39;production&#39;</code> 和 <code>process.isClient</code> 实际体验应该都差不多。上面两处注释掉的 <code>maxNest</code> 是我修改后具有的功能，原版开启后不会有效果，该项不设置时默认显示三层嵌套。</p>
<h2 id="最终模板">最终模板</h2>
<p><del>在 <code>/src/components</code> 新建 <code>ArtalkCards.vue</code> 作为 Artalk 评论区模板</del> 我对 Gridsome 的模板还不太熟悉，总之直接在需要引入评论区的页面直接加好了：</p>
<pre><code class="language-html">&lt;template&gt;

  &lt;!-- --&gt;

  &lt;div class=&quot;artalk-cards&quot;&gt;
    &lt;details class=&quot;admonition admonition-warning&quot;&gt;
      &lt;summary&gt;
        Comment on this blog
      &lt;/summary&gt;
      &lt;p&gt;
        评论如无特殊原因均不会被删除，提交前请三思。&lt;br /&gt;
        你应该懂得如何发表适当的观点，请对自己的言论负责。
      &lt;/p&gt;
    &lt;/details&gt;
    &lt;div id=&quot;LetsArtalk&quot;&gt;&lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- --&gt;

&lt;/template&gt;

&lt;script&gt;
// ...

import &#39;artalk/dist/Artalk.css&#39;

export default {

  // ...

  mounted() {

    // ...

    // Initialize post comment by Artalk
    if (process.env.NODE_ENV === &#39;production&#39;) {
      let Artalk = require(&#39;artalk&#39;)
      var artalk = new Artalk({
        el: &#39;#LetsArtalk&#39;,
        placeholder: &#39;说点什么 (づ￣ 3￣)づ&#39;,
        defaultAvatar: &#39;mp&#39;,
        // maxNest: 2,
        pageKey: &#39;https://blog.monsterx.cn&#39; + this.$page.post.path,
        serverUrl: &#39;https://lab.monsterx.cn/ArtalkServer&#39;,
        readMore: {
          pageSize: 15,
          autoLoad: true,
        },
      })
    }
  },
}
&lt;/script&gt;

&lt;page-query&gt;
query Post ($id: ID!) {

  // ...

  post: post (id: $id) {
    path
  }
}
&lt;/page-query&gt;

&lt;style lang=&quot;scss&quot;&gt;
.artalk-cards {
  background: var(--at-bg-main);
  border-radius: var(--radius);
  max-width: var(--content-width);
  margin: 20px auto 100px;
  box-shadow: 1px 1px 5px 0 rgba(0, 0, 0, 0.02),
    1px 1px 15px 0 rgba(0, 0, 0, 0.03);
  details {
    margin: 0 auto;
    text-align: center;
    border-top-left-radius: var(--radius);
    border-top-right-radius: var(--radius);
    font-weight: 600;
    outline: none;
    summary {
      list-style: none;
      margin: 4px auto !important;
      color: var(--cb-admonition-icon-color) !important;
      margin: 2.75rem 0 1rem;
      font-family: var(--title-font-family);
      line-height: 1.5;
      outline: none;
    }
    summary::-webkit-details-marker {
      display: none;
    }
    p {
      color: var(--at-font-color);
      margin-bottom: 0;
    }
  }
  #LetsArtalk {
    padding: 20px;
  }
  @media screen and (max-width: 767.5px) {
    details &gt; p {
      text-align: left;
    }
    #LetsArtalk {
      padding: 20px 0 0 0;
    }
  }
}

/** */
&lt;/style&gt;
</code></pre>
<p>根据需要自己修改下 <code>&lt;template&gt;</code> 的内容，注意保证只存在一个「主标签」，比如我的是 <code>&lt;div class=&quot;artalk-cards&quot;&gt;</code>。修改 L29-37 为自己的 Artalk 参数，<code>pageKey</code> 需要自行拼接为页面 URL，否则后端发送的邮件中「查看回复」按钮可能链接到奇怪的地方导致体验极差，其他参数查阅 <a href="https://github.com/monsterxcn/Artalk/blob/master/types/artalk-config.d.ts">artalk-config.d.ts</a>。<code>&lt;style&gt;</code> 是我针对当前主题做的一点适配。</p>
<p>考虑到能看到这里并且有意愿尝试 Artalk 的人应该极少，我悄悄说一句大家可以使用我搭的 Artalk PHP 后端尝尝鲜吖，它运行在阿里云 <del>北京</del> 上海学生机，并发访问除了我自己的站点应该就没了，而我自己的站点访问也很少，所以服务器压力不大，给大家玩玩还是可以的。将配置中的 <code>serverUrl</code> 字段填写为 <code>https://lab.monsterx.cn/ArtalkServer</code> 来使用本站后端，跨域访问目前允许，不必向我申请。</p>
<blockquote>
<p>其实通过 phpcomposer 安装搭建 Artalk PHP 后端也十分简单。目前发现需要注意的是 PHP 得开启 GD 库和 FreeType 支持，否则无法生成图形验证码。<br />
使用别人的后端存在一些不足之处：邮件模板、发信设置只能使用搭建者的，目前 Artalk 对多站点的支持尚不完整。<br />
担心引用本站后端存在数据安全或其他问题可以尝试自行搭建。<del>以后有空可能写一篇 Docker Artalk PHP 后端的文。</del> 如果对上述内容有问题欢迎留言。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub README.md 显示博文并自动更新]]></title>
        <id>https://blog.monsterx.cn/code/update-your-posts-in-readme/</id>
        <link href="https://blog.monsterx.cn/code/update-your-posts-in-readme/"/>
        <updated>2020-08-18T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>今年 GitHub 推出了 profile-level README 的新特性，只要新建与用户名同名仓库并创建 <code>README.md</code> 就可以在 GitHub 个人主页上看到其内容。比起单纯的固定仓库或 Gist 在个人主页，我觉得这会让 GitHub 主页变得更多姿多彩，戳官方 <a href="https://docs.github.com/en/github/setting-up-and-managing-your-github-profile/managing-your-profile-readme">文档</a> 了解更多。然而，像我这种菜鸟想了很久都没有想清楚在个人主页上到底写点什么，拿得出手的项目是不存在的，刷 commit 也只是满足下自己的虚荣心而已，能力提升微乎其微。</p>
<p>这段时间看了很多个人介绍仓库之后，发现我想多了：GitHub 是什么？<del>全球最大的同性交友网站啊！</del> 又不是世纪佳缘，写得漂亮能找着对象吗？开心就好，介绍下自己，放张关于自己仓库的小卡片，留点 E-mail Twitter 之外更丰富的社交链接，这个 <code>README.md</code> 就达标辣！（靠 GitHub 找工作的话那当我没说。</p>
<p>单单写 READMD 没什么好记录的，本文就记录一下自己为了让 README 稍稍有点逼格，制作「从 RSS 获取最近更新并以 Markdown 格式写入 README」功能的经过吧。毕竟对于萌新我来说，做出点有意思的东西是很有成就感的。</p>
<blockquote>
<p>写着写着就变成了幼儿读物的感觉，请不要笑话我了，毕竟我是个萌新，阿巴阿巴 🤪 <br />
看完这篇文章你至少会了解到「萌新如何开始学习别人的代码」「GitHub Actions 如何跨仓库执行」「从 <code>workflows_run</code> 触发工作流」</p>
</blockquote>
<h2 id="从文章中学习">从文章中学习</h2>
<p>一切是从这里开始的：《<a href="https://simonwillison.net/2020/Jul/10/self-updating-profile-readme/">Building a self-updating profile README for GitHub - Simon Willison’s Weblog</a>》，这位作者的仓库 <a href="https://github.com/simonw/simonw">@simonw/simonw</a> 显示了三栏自动更新的内容，包括 GitHub 上的打包发布、博客文章和另外一个站点 T(hings) I L(earned) 的条目。这三栏分别使用了三种途径获取最新内容的，均由 Python 实现：</p>
<ul>
<li>「GitHub GraphQL API -&gt; python_graphql_client -&gt; Latest Release」</li>
<li>「RSS Atom feed -&gt; feedparser -&gt; Latest posts」</li>
<li>「Datasette API -&gt; SQL query -&gt; Latest entries」</li>
</ul>
<p>第一个和第三个我都不了解，只有 RSS 的格式稍微懂一点，巧的是这正好能用来获取博客最新的文章。动手开始！</p>
<h2 id="面向谷歌编程">面向谷歌编程</h2>
<p>查看仓库现成的 <code>build_readme.py</code> 文件，一眼扫下来有 218 行，有点晕。一遍看下来 GitHub GraphQL API 和 Datasette API 相关的占了较大篇幅，这说明通过 RSS 获取博客内容的代码较少。这时候我选择找到第一个版本的文件，我觉得最初的版本大概率应该是最简陋的，能让我最快的搞清楚代码的大体结构。第一个版本的 <a href="https://github.com/simonw/simonw/commit/d2b5e8ba30b0d2b1a867e0bfafa1215a2b5ef287#diff-b8502c56279bd4ac52ccb69f70e81a13">build_readme.py</a> L139，就从这里开始吧。</p>
<details><summary><strong>从零开始学 Copy</strong></summary><br />


<p>从 L107 <code>if __name__ == &quot;__main__&quot;</code> 处开始读，截取在下面 L1。这句相当于 C 语言的 <code>int main()</code>（尝试白嫖腾讯云无服务器环境的时候从环境设置里学到的。</p>
<pre><code class="language-python">if __name__ == &quot;__main__&quot;:
    readme = root / &quot;README.md&quot;
    releases = fetch_releases(TOKEN)
    releases.sort(key=lambda r: r[&quot;published_at&quot;], reverse=True)
    md = &quot;\n&quot;.join(
        [
            &quot;* [{repo} {release}]({url}) - {published_at}&quot;.format(**release)
            for release in releases[:10]
        ]
    )
    readme_contents = readme.open().read()
    rewritten = replace_chunk(readme_contents, &quot;recent_releases&quot;, md)

    tils = fetch_tils()
    tils_md = &quot;\n&quot;.join(
        [
            &quot;* [{title}]({url}) - {created_at}&quot;.format(
                title=til[&quot;title&quot;],
                url=til[&quot;url&quot;],
                created_at=til[&quot;created_utc&quot;].split(&quot;T&quot;)[0],
            )
            for til in tils
        ]
    )
    rewritten = replace_chunk(rewritten, &quot;tils&quot;, tils_md)

    entries = fetch_blog_entries()[:10]
    entries_md = &quot;\n&quot;.join(
        [&quot;* [{title}]({url}) - {published}&quot;.format(**entry) for entry in entries]
    )
    rewritten = replace_chunk(rewritten, &quot;blog&quot;, entries_md)

    readme.open(&quot;w&quot;).write(rewritten)
</code></pre>
<p><code>release</code> <code>til</code> 命名的很显然是获取 GitHub 和 TIL 最新内容相关，于是获取博客更新的主要代码就筛选出来了：L1-2 L27-33。L2 用到的变量 <code>root</code> 并没有出现定义，接下来找他的定义和用到的函数 <code>fetch_blog_entries()</code> <code>replace_chunk()</code>。</p>
<pre><code class="language-python">root = pathlib.Path(__file__).parent.resolve()    # 库 pathlib

## ...

def replace_chunk(content, marker, chunk):
    r = re.compile(                               # 库 re
        r&quot;&lt;!\-\- {} starts \-\-&gt;.*&lt;!\-\- {} ends \-\-&gt;&quot;.format(marker, marker),
        re.DOTALL,
    )
    chunk = &quot;&lt;!-- {} starts --&gt;\n{}\n&lt;!-- {} ends --&gt;&quot;.format(marker, chunk, marker)
    return r.sub(chunk, content)

## ...

def fetch_blog_entries():
    # 库 feedparser
    entries = feedparser.parse(&quot;https://simonwillison.net/atom/entries/&quot;)[&quot;entries&quot;]
    return [
        {
            &quot;title&quot;: entry[&quot;title&quot;],
            &quot;url&quot;: entry[&quot;link&quot;].split(&quot;#&quot;)[0],
            &quot;published&quot;: entry[&quot;published&quot;].split(&quot;T&quot;)[0],
        }
        for entry in entries
    ]
</code></pre>
<p>看起来有些许复杂，此时应该提取出用到的 Python 库，实际调试的时候只要尝试单独运行这些代码块会得到未定义之类的错误，然后就能定位到缺失的库。在 Python 文件开头使用 <code>import</code> 导入。</p>
</details><br />


<p>下面是正式的面向谷歌编程，也就是学习用轮子（作者用到的那些库 pathlib、re、feedparser）：pathlib 库看起来没有需要谷歌的，一个能获取文件路径的库。re 库用到了正则表达式，结合作者在仓库第一版 <code>README.md</code> 中写的 <code>&lt;!-- blog starts --&gt;</code> <code>&lt;!-- blog ends --&gt;</code> 这样的标记，不难理解是将结果通过正则匹配找到位置，然后进行替换。feedparser 库从一个 Atom 链接获取了包含文章信息的数组，是为「源头」。</p>
<h3 id="feedparser-解析-rss">feedparser 解析 RSS</h3>
<p>《<a href="https://vimsky.com/article/4399.html">在 Python 中使用 Feedparser 解析 RSS - 纯净天空</a>》一篇足矣，或者看英文版《<a href="https://www.pythonforbeginners.com/feedparser/using-feedparser-in-python">Using Feedparser in Python - PythonForBeginners</a>》。当然，RSS 文件也要有一丢丢了解。XML 格式由 HTML 触类旁通不难理解，可以试着戳 <a href="https://blog.monsterx.cn/feed.xml">这里</a> 看看本站的 RSS 源格式。在每个 <code>&lt;item&gt;</code> 中包含了 <code>&lt;title&gt;</code> <code>&lt;link&gt;</code> <code>&lt;pubDate&gt;</code>，用来输出到 <code>README.md</code> 够了。</p>
<p>参考链接文章用的是 <code>dic[&#39;feed&#39;]</code> 这种格式，用起来和 <code>dic.feed</code> 是一样的，就用后面这种短一点的写个示例。</p>
<pre><code class="language-python">import feedparser

# 解析本站的 RSS 源
dic = feedparser.parse(&#39;https://blog.monsterx.cn/feed.xml&#39;)
channel = dic.feed                 # 获取 &lt;channel&gt; 数据
items = dic.entries                # 获取 &lt;item&gt; 数据
item = items[0]                    # 获取第一个 &lt;item&gt; 数据
sitetitle = channel.title          # 获取 &lt;channel&gt;&lt;title&gt; 数据
sitelink = channel.link            # 获取 &lt;channel&gt;&lt;link&gt; 数据
posttitle = items[0].title         # 获取 &lt;item&gt;&lt;title&gt; 数据
postlink = items[0].link           # 获取 &lt;item&gt;&lt;link&gt; 数据
postdate = items[0].published      # 获取 &lt;item&gt;&lt;pubDate&gt; 数据

print(sitetitle)
</code></pre>
<p>RSS 数据较多时 <code>print(dic)</code> 可能让人头皮发麻，自行体会吧。下面给出更直观的对比：</p>
<pre><code class="language-html">&lt;rss xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot; xmlns:content=&quot;http://purl.org/rss/1.0/modules/content/&quot; xmlns:atom=&quot;http://www.w3.org/2005/Atom&quot; version=&quot;2.0&quot;&gt;
    &lt;channel&gt;
        &lt;title&gt;Monstx&#39;s Blog&lt;/title&gt;
        &lt;link&gt;https://blog.monsterx.cn/&lt;/link&gt;
        &lt;description&gt;Monsterx CN - 学生 / 前端 / 电气&lt;/description&gt;
        &lt;lastBuildDate&gt;Tue, 18 Aug 2020 04:11:01 GMT&lt;/lastBuildDate&gt;
        &lt;docs&gt;https://validator.w3.org/feed/docs/rss2.html&lt;/docs&gt;
        &lt;generator&gt;Gridsome Feed Plugin&lt;/generator&gt;
        &lt;atom:link href=&quot;https://blog.monsterx.cn/feed.xml&quot; rel=&quot;self&quot; type=&quot;application/rss+xml&quot;/&gt;
        &lt;item&gt;
            &lt;title&gt;
                &lt;![CDATA[ New Start ]]&gt;
            &lt;/title&gt;
            &lt;link&gt;https://blog.monsterx.cn/life/new-start-with-gridsome/&lt;/link&gt;
            &lt;guid&gt;https://blog.monsterx.cn/life/new-start-with-gridsome/&lt;/guid&gt;
            &lt;pubDate&gt;Sat, 15 Aug 2020 00:00:00 GMT&lt;/pubDate&gt;
            &lt;content:encoded&gt;
                &lt;![CDATA[ &lt;p&gt;在这普通的一天，我穿着普通的鞋...&lt;/p&gt; ]]&gt;
            &lt;/content:encoded&gt;
        &lt;/item&gt;
        &lt;item&gt;
            &lt;!-- 另外一篇文章 --&gt;
        &lt;/item&gt;
        &lt;item&gt;
            &lt;!-- 另外一篇文章 --&gt;
        &lt;/item&gt;
    &lt;/channel&gt;
&lt;/rss&gt;
</code></pre>
<p>解析后：</p>
<details><summary><strong>freeparser 解析结构</strong></summary><br />


<pre><code class="language-json">{
  &#39;feed&#39;: {
    &#39;title&#39;: &quot;Monstx&#39;s Blog&quot;, 
    &#39;title_detail&#39;: {
      &#39;type&#39;: &#39;text/plain&#39;, 
      &#39;language&#39;: None, 
      &#39;base&#39;: &#39;https://blog.monsterx.cn/feed.xml&#39;, 
      &#39;value&#39;: &quot;Monstx&#39;s Blog&quot;
    }, 
    &#39;links&#39;: [
      {
        &#39;rel&#39;: &#39;alternate&#39;, 
        &#39;type&#39;: &#39;text/html&#39;, 
        &#39;href&#39;: &#39;https://blog.monsterx.cn/&#39;
      }, {
        &#39;href&#39;: &#39;https://blog.monsterx.cn/feed.xml&#39;, 
        &#39;rel&#39;: &#39;self&#39;, 
        &#39;type&#39;: &#39;application/rss+xml&#39;
      }
    ], 
    &#39;link&#39;: &#39;https://blog.monsterx.cn/&#39;, 
    &#39;subtitle&#39;: &#39;Monsterx CN - 学生 / 前端 / 电气&#39;, 
    &#39;subtitle_detail&#39;: {
      &#39;type&#39;: &#39;text/html&#39;, 
      &#39;language&#39;: None, 
      &#39;base&#39;: &#39;https://blog.monsterx.cn/feed.xml&#39;, 
      &#39;value&#39;: &#39;Monsterx CN - 学生 / 前端 / 电气&#39;
    }, 
    &#39;updated&#39;: &#39;Tue, 18 Aug 2020 04:11:01 GMT&#39;, 
    &#39;updated_parsed&#39;: time.struct_time(tm_year=2020, tm_mon=8, tm_mday=18, tm_hour=4, tm_min=11, tm_sec=1, tm_wday=1, tm_yday=231, tm_isdst=0), 
    &#39;docs&#39;: &#39;https://validator.w3.org/feed/docs/rss2.html&#39;, 
    &#39;generator_detail&#39;: {&#39;name&#39;: &#39;Gridsome Feed Plugin&#39;}, 
    &#39;generator&#39;: &#39;Gridsome Feed Plugin&#39;
  }, 
  &#39;entries&#39;: [
    {
      &#39;title&#39;: &#39;New Start&#39;, 
      &#39;title_detail&#39;: {
        &#39;type&#39;: &#39;text/plain&#39;, 
        &#39;language&#39;: None, 
        &#39;base&#39;: &#39;https://blog.monsterx.cn/feed.xml&#39;, 
        &#39;value&#39;: &#39;New Start&#39;
      }, 
      &#39;links&#39;: [
        {
          &#39;rel&#39;: &#39;alternate&#39;, 
          &#39;type&#39;: &#39;text/html&#39;, 
          &#39;href&#39;: &#39;https://blog.monsterx.cn/life/new-start-with-gridsome/&#39;
        }
      ], 
      &#39;link&#39;: &#39;https://blog.monsterx.cn/life/new-start-with-gridsome/&#39;, 
      &#39;id&#39;: &#39;https://blog.monsterx.cn/life/new-start-with-gridsome/&#39;, 
      &#39;guidislink&#39;: False, 
      &#39;published&#39;: &#39;Sat, 15 Aug 2020 00:00:00 GMT&#39;, 
      &#39;published_parsed&#39;: time.struct_time(tm_year=2020, tm_mon=8, tm_mday=15, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=5, tm_yday=228, tm_isdst=0), 
      &#39;content&#39;: [
        {
          &#39;type&#39;: &#39;text/html&#39;, 
          &#39;language&#39;: None, 
          &#39;base&#39;: &#39;https://blog.monsterx.cn/feed.xml&#39;, 
          &#39;value&#39;: &#39;&lt;p&gt;在这普通的一天，我穿着普通的鞋...&lt;/p&gt;&#39;
        }
      ], 
      &#39;summary&#39;: &#39;&lt;p&gt;在这普通的一天，我穿着普通的鞋...&lt;/p&gt;&#39;
    }, {
      // 另外一篇文章
    }
  ], 
  &#39;bozo&#39;: 0, 
  &#39;headers&#39;: {
    &#39;Server&#39;: &#39;Tengine&#39;, 
    &#39;Content-Type&#39;: &#39;application/xml&#39;, 
    &#39;Transfer-Encoding&#39;: &#39;chunked&#39;, 
    &#39;Connection&#39;: &#39;close&#39;, 
    &#39;Vary&#39;: &#39;Accept-Encoding&#39;, 
    &#39;Strict-Transport-Security&#39;: &#39;max-age=31536000&#39;, 
    &#39;Date&#39;: &#39;Tue, 18 Aug 2020 13:37:32 GMT&#39;, 
    &#39;x-oss-request-id&#39;: &#39;5F3BD99C7DD3BB333136465D&#39;, 
    &#39;x-oss-cdn-auth&#39;: &#39;success&#39;, 
    &#39;ETag&#39;: &#39;W/&quot;7885150FF626A52F9C8E511300EDC191&quot;&#39;, 
    &#39;Last-Modified&#39;: &#39;Tue, 18 Aug 2020 04:11:35 GMT&#39;, 
    &#39;x-oss-object-type&#39;: &#39;Normal&#39;, 
    &#39;x-oss-hash-crc64ecma&#39;: &#39;904326687370716414&#39;, 
    &#39;x-oss-storage-class&#39;: &#39;Standard&#39;, 
    &#39;x-oss-server-side-encryption&#39;: &#39;AES256&#39;, 
    &#39;Content-MD5&#39;: &#39;eIUVD/YmpS+cjlETAO3BkQ==&#39;, 
    &#39;x-oss-server-time&#39;: &#39;40&#39;, 
    &#39;Via&#39;: &#39;cache36.l2cm9-5[104,0], kunlun8.cn2479[127,0]&#39;, 
    &#39;Timing-Allow-Origin&#39;: &#39;*&#39;, 
    &#39;EagleId&#39;: &#39;249c511c15977578523801838e&#39;, 
    &#39;Content-Encoding&#39;: &#39;gzip&#39;
  }, 
  &#39;etag&#39;: &#39;W/&quot;7885150FF626A52F9C8E511300EDC191&quot;&#39;, 
  &#39;updated&#39;: &#39;Tue, 18 Aug 2020 04:11:35 GMT&#39;, 
  &#39;updated_parsed&#39;: time.struct_time(tm_year=2020, tm_mon=8, tm_mday=18, tm_hour=4, tm_min=11, tm_sec=35, tm_wday=1, tm_yday=231, tm_isdst=0), 
  &#39;href&#39;: &#39;https://blog.monsterx.cn/feed.xml&#39;, 
  &#39;status&#39;: 200, 
  &#39;encoding&#39;: &#39;utf-8&#39;, 
  &#39;version&#39;: &#39;rss20&#39;, 
  &#39;namespaces&#39;: {
    &#39;dc&#39;: &#39;http://purl.org/dc/elements/1.1/&#39;, 
    &#39;content&#39;: &#39;http://purl.org/rss/1.0/modules/content/&#39;, 
    &#39;&#39;: &#39;http://www.w3.org/2005/Atom&#39;
  }
}
</code></pre>
</details><br />


<p>可以看到解析出来像是 JSON 格式，而且不仅仅包含 XML 文件可见内容，HTTP Header 信息也在其中。值得注意的地方： <code>&lt;item&gt;&lt;pubDate&gt;</code> 并不是通过形如 <code>items[0].pubDate</code> 获取，而是 <code>items[0].published</code> 。根据这个结构更加灵活的运用 feedparser 吧！实现 README 自动更新最近博文并不需要这些，我给的示例足够用了。</p>
<h3 id="re-正则表达式替换">re 正则表达式替换</h3>
<p>学 re 库从 Python 官方文档开始：《<a href="https://docs.python.org/zh-cn/3/library/re.html">re --- 正则表达式操作 - Python 3 中文文档</a>》。不过最重要的还是学会写正则表达式，多写一些多搜一搜，时间久了自然就会了，我是这么想的。这里给出用于匹配 <strong>指定字符串之间所有内容且不包含指定字符串</strong> 的正则表达式。</p>
<ul>
<li><code>(?&lt;=MARK)</code> 指定以 <code>MARK</code> 开头，遇到 <code>MARK</code> 后开始匹配</li>
<li><code>(?=MARK)</code> 指定 <code>MARK</code> 结尾，遇到 <code>MARK</code> 前停止匹配</li>
<li><code>.</code> 在默认模式匹配除了换行的任意字符。re 库中如果指定了标签 <code>DOTALL</code> 则匹配包括换行符的任意字符</li>
<li><code>*</code> 对它前面的正则式匹配 0 到任意次重复，尽可能多地匹配</li>
</ul>
<pre><code class="language-python"># 拼接正则表达式并指定标签 DOTALL
# (?&lt;=(STARTMARK)).*(?=(ENDMARK))

start = &quot;&lt;!-- posts start --&gt;&quot;
end = &quot;&lt;!-- posts end --&gt;&quot;
pattern = re.compile(
    r&quot;(?&lt;=(&quot; + start + r&quot;)).*(?=(&quot; + end + r&quot;))&quot;,
    re.DOTALL,
)
</code></pre>
<p><code>re.compile()</code> 将正则表达式的样式编译为一个正则表达式对象（正则对象），如果需要多次使用一个正则表达式的话，使用 <code>re.compile()</code> 保存这个正则对象以便复用，可以让程序更加高效。参数：<code>re.compile(pattern, flags=0)</code>，参考官方文档给出介绍如下：</p>
<blockquote>
<p><strong>re.sub(pattern, repl, string, count=0, flags=0)</strong> [^1] <br />
返回通过使用 <code>repl</code> 替换在 <code>string</code> 最左边非重叠出现的 <code>pattern</code> 匹配的字符串。</p>
</blockquote>
<ul>
<li><code>pattern</code> 可以是字符串或对象，在无匹配到时原样返回 <code>string</code></li>
<li><code>repl</code> 可以是字符串或函数。<code>pattern</code> 为字符串时 <code>repl</code> 中任何反斜杠转义序列都会被处理，如 <code>\n</code> 会被转换为换行符、<code>\r</code> 会被转换为回车符。ASCII 字符的未知转义符会被保留供将来使用并被视为错误。其他未知转义符例如 <code>\&amp;</code> 会保持原样。反向引用（Backreferences）例如 <code>\6</code> 将被替换为 <code>pattern</code> 所匹配到的第 6 组的子字符串</li>
<li><code>repl</code> 是字符串时，对所述的转义符和反向引用（Backreferences）中有几处特殊需要说明<ul>
<li>形如 <code>\g&lt;name&gt;</code> 用作 <code>(?P&lt;name&gt;…)</code> 语法定义的 <code>name</code> 组的匹配到的子字符串</li>
<li>形如 <code>\g&lt;number&gt;</code> 用作对应数字的组，例如 <code>\g&lt;2&gt;</code> 就是 <code>\2</code>，但它避免了同 <code>\g&lt;2&gt;0</code> 的歧义</li>
<li>形如 <code>\20</code> 会被解释为组 <code>20</code>，而不是组 <code>2</code> 后面跟随一个字符 <code>0</code></li>
<li>反向引用（Backreferences）例如 <code>\g&lt;0&gt;</code> 等同于由 <code>pattern</code> 匹配的整个子字符串</li>
</ul>
</li>
<li><code>repl</code> 是函数时，在每次非重叠出现 <code>pattern</code> 时都会被调用。这个函数只能有一个 <em>匹配对象</em> 参数，并返回替换后的字符串</li>
<li>可选参数 <code>count</code> 是要替换的最大次数，必须为非负整数。如果忽略这个参数或设置为 0，所有的匹配都会被替换</li>
<li>空匹配（Empty matches）仅在不与先前的空匹配相邻时，才被替换。所以 <code>sub(&#39;x*&#39;, &#39;-&#39;, &#39;abxd&#39;)</code> 将返回 <code>-a-b--d-</code></li>
</ul>
<p>文档太专业了，总之 <code>re.sub(pattern, repl, string)</code> 可以用 <code>repl</code> 替换掉 <code>string</code> 内所有与 <code>pattern</code> 匹配的内容，这便是最基础的用法了。使用编译后的样式 <code>pattern.sub(repl, string)</code> 效果一样。</p>
<p>写个示例：</p>
<pre><code class="language-python">import re

start = &quot;STARTMARK&quot;
end = &quot;ENDMARK&quot;
repl = &quot;text used to replace&quot;
contents = &quot;&quot;&quot;text wait STARTMARK ing for being ENDMARK replaced&quot;&quot;&quot;

pattern = re.compile(
  r&quot;(?&lt;=(&quot; + start + r&quot;)).*(?=(&quot; + end + r&quot;))&quot;,
  re.DOTALL,
)
pattern.sub(repl, contents)

print(contents)
</code></pre>
<p>最终输出 <code>contents</code> 为 <code>text wait STARTMARKtext used to replaceENDMARK replaced</code>。</p>
<h3 id="python-文件读写">Python 文件读写</h3>
<p>懒得深究了，因为从之前作者的代码里找到了关于读写的:</p>
<pre><code class="language-python"># 当前文件的文件夹路径
thisdir = pathlib.Path(__file__).parent.resolve()
# .py 与 README.md 同级时获取 README 完整路径
thisfile = thisdir / &quot;README.md&quot;
# 取得 README 内容
contents = thisfile.open().read()
# 结合之前的 re 库示例实现替换
readme.open(&quot;w&quot;).write(pattern.sub(repl, contents))
</code></pre>
<p>C 语言文件读写 <code>fopen()</code> 后还有 <code>fclose()</code> 的，作者的代码里没有找到 close 之类的。应该是程序结束默认关闭了吧，急于实现功能，此处没有留意。</p>
<h2 id="整理整套代码">整理整套代码</h2>
<p>以上所有学习途径自以为都交代清楚了，最后整合时用了 <code>for</code> 循环和数组的 <code>[start:end:step]</code> 分割（像数学上的区间表示法）来获取最近的固定篇数，完整实现这个「从 RSS 获取最近更新并以 Markdown 格式写入 README」的功能需要的代码篇幅很短，Python 真有趣！</p>
<pre><code class="language-python">import feedparser
import pathlib
import re

rssUrl = &quot;https://blog.monsterx.cn/feed.xml&quot;
startMark = r&quot;&lt;!-- posts start --&gt;&quot;
endMark = r&quot;&lt;!-- posts end --&gt;&quot;
NUM = 5

def update_readme(start, end, repl):
    # Splicing complete regular expressions
    pattern = re.compile(
        r&quot;(?&lt;=(&quot; + start + r&quot;)).*(?=(&quot; + end + r&quot;))&quot;,
        re.DOTALL,
    )
    # Get contents and rewrite README.md
    readme = pathlib.Path(__file__).parent.resolve() / &quot;README.md&quot;
    readme_contents = readme.open().read()
    readme.open(&quot;w&quot;).write(pattern.sub(&#39;\n&#39; + repl + &#39;\n&#39;, readme_contents))

def fetch_posts(url):
    blog = feedparser.parse(url)
    posts = blog[&#39;entries&#39;]
    markdown = &quot;\n&quot;
    # Fetch only 5 latest posts&#39; info
    # My post.published return &quot;Tue, 30 Jun 2020 00:00:00 GMT&quot;
    # So I just intercept the middle part of the character
    for post in posts[:NUM]:
        # markdown += &quot; ※ 《[&quot; + post.title + &quot;](&quot; + post.link + &quot;)》&quot; + post.published + &quot;&lt;br /&gt;\n&quot;
        markdown += &quot; ※ 《[&quot; + post.title + &quot;](&quot; + post.link + &quot;)》&quot; + post.published[5:16] + &quot;&lt;br /&gt;\n&quot;
    markdown += &quot;\n\n [Read more..](&quot; + blog[&#39;feed&#39;][&#39;link&#39;] + &quot;)\n&quot;
    return markdown

if __name__ == &quot;__main__&quot;:
    postsNew = fetch_posts(rssUrl)
    update_readme(startMark, endMark, postsNew)
</code></pre>
<p>按需小小修改一下，执行 <code>python this.py</code> 即可替换指定字符串之间内容为最新的博客文章。「自动」的事情依旧交给 GitHub Actions，设置自己点 Star 触发和定时执行即可。给出我的工作流配置 <a href="https://github.com/monsterxcn/monsterxcn/blob/master/.github/workflows/new.yml">new.yml</a>，和之前打卡项目相同的原理。（看到这里的你也许有兴趣读读我之前编写这种定时工作流的文章 🤣。</p>
<p>上面的定时执行工作流也许对于像我这种更新缓慢的博客来说有点浪费，于是我又写了个从「博客」仓库执行的工作流，这样只要「博客」仓库有文章更新就会第一时间更新 README！使用前先根据《<a href="https://docs.github.com/en/github/authenticating-to-github/creating-a-personal-access-token">Creating a personal access token - GitHub Docs</a>》创建一个 Personal Access Token，要有写入仓库的权限。然后将生成的 Token 作为 Secrets 写入「博客」仓库。最后在「博客」仓库新建 <code>readme.yml</code>。</p>
<p>由于我的博客仓库暂时没有公开（想到稳定两周年那天再公开，整点仪式感），所以直接将仓库里的工作流贴在这里吧。只需要将自己的站点发布工作流名称、Token 在「博客」仓库中的 Secrets 名称、README 仓库地址修改到下面 L10 L22-23 即可。</p>
<p>编写参考 <a href="https://github.com/actions/checkout">@actions/checkout</a> 和《<a href="https://docs.github.com/en/actions/reference/events-that-trigger-workflows#workflow_run">Events that trigger workflows #workflow_run - GitHub Docs</a>》</p>
<details><summary><strong>从「博客」仓库更新 profile README 的工作流 readme.yml</strong></summary><br />


<pre><code class="language-yaml">name: Update README

on:
  # 直接使用 push 触发可能无法获取最新状态
  # 这里设为在发布工作流执行完毕之后触发
  # push:
  #   branches:
  #     - master
  workflow_run:
    workflows: [&quot;Deploy to OSS&quot;]      # 修改为你的站点发布工作流 name
    types: 
      - completed

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v2
        with:
          token: ${{ secrets.UPDATE_README }}   # 修改为自定义的 Secrets 名
          repository: monsterxcn/monsterxcn     # 修改为 README 仓库地址

      - name: Setup
        uses: actions/setup-python@v2
        with:
          python-version: &#39;3.x&#39;

      - name: Install
        run: pip install feedparser

      - name: Update
        run: python build_readme.py

      - name: Commit
        env:
          TZ: Asia/Shanghai
        run: |
          git config --local user.email &quot;github-actions[bot]@users.noreply.github.com&quot;
          git config --local user.name &quot;github-actions[bot]&quot;
          git add README.md
          git commit -m \
          &quot;:beers: Update from BlogRepo at \
          $(date +&quot;%Y-%m-%d %H:%M&quot;) \
          &quot; --allow-empty
          git push
</code></pre>
</details><br />


<blockquote>
<p>我的 README [^2] 使用了 <a href="https://github.com/anuraghazra/github-readme-stats">@anuraghazra/github-readme-stats</a> 展示 GitHub 账号的统计信息，使用了 <a href="https://shields.io">Shields.io</a> 和 <a href="https://simpleicons.org">Simple Icons</a> 生成精致的图标。快来给自己也安排一个吧！</p>
</blockquote>
<p>[^1]: 《<a href="https://docs.python.org/zh-cn/3/library/re.html#re.sub">re --- 正则表达式操作 --- re.sub - Python 3 中文文档</a>》
[^2]: GitHub 仓库地址 <a href="https://github.com/monsterxcn/monsterxcn">@monsterxcn/monsterxcn</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[新起点 × 博客中文排版]]></title>
        <id>https://blog.monsterx.cn/life/new-start-with-gridsome/</id>
        <link href="https://blog.monsterx.cn/life/new-start-with-gridsome/"/>
        <updated>2020-08-15T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>在这普通的一天，我穿着普通的鞋，很普通地呆在这普通的家，掏出普通的耳机，找点普通的感觉，来一首我最爱的普通音乐，踩着普通的鼓点，世界随着我旋转，这让我普通地单曲循环，跟着普通的节奏，手腕普通地抖动，这普通的一切，都变得不同……</p>
<h2 id="新的平台">新的平台</h2>
<p>博客稳定两周年之际，我正式从动态博客迁移至静态博客，如你所见这个博客正由 <a href="https://gridsome.org">Gridsome</a> 驱动着。「Gridsome 是一个免费、开源、基于 Vue.js 构建的框架，用 Gridsome 创建的网站和应用程序具有天然的速度优势」，身边用 <a href="https://hexo.io">Hexo</a> 的人似乎太多了，喜欢尝试小众作品的我选择了 Gridsome。除此之外，似乎是从给旧站点加了 Statusbot <a href="https://status.monsterx.cn">状态监控</a> 开始站内垃圾评论数量陡增，一直在用 Typecho 原生评论的我实在顶不住，评论拦截插件虽然也有，但都不太能满足我的需求，索性换个评论系统加入大家都说好的 Disqus 大家族了。</p>
<p>使用 Disqus 的痛处其一是评论数据同步，手动导入了两篇文章的数据之后发现评论区头像都无法显示，网上的解决方案似乎得购买 Disqus 商业套餐。其二是国内用户上网环境不佳便无法评论，向来冷清的本站雪上加霜，以后可能会考虑在国内服务器上继续部署 <a href="https://lab.mocurio.com/artalk.html">Artalk</a> 评论系统以供 <del>小部分人的需求</del> 自娱自乐。</p>
<p>本站的主题参考 <a href="https://blog.spencerwoo.com">@Spencer&#39;s Blog</a> 和 <a href="https://blog.jalenchuh.cn">@Jalen&#39;s Blog</a> 的仓库修改，基于 <a href="https://github.com/gridsome/gridsome-starter-blog">@gridsome/gridsome-starter-blog</a>。静态博客可以自由部署在很多地方，目前这个博客通过 GitHub Actions 自动构建静态文件发布到私有仓库的分支和阿里云 OSS，配合阿里云全站加速供中国境内访问，同时部署到 Cloudflare Workers Sites 供境外访问。以前将域名的境内境外解析拆分，是考虑国外可能会有人访问，现在想明白了，这其实是为了国内日常科学上网的同志们。就算是「人在纽约」访问本站应该也能获取稍快的体验。</p>
<h2 id="文章排版">文章排版</h2>
<p>格式工整的文章让人阅读的欲望更强烈。参照众多中文博客排版、GitHub 热门项目文档排版、GitHub 仓库 <a href="https://github.com/sparanoid/chinese-copywriting-guidelines">@sparanoid/chinese-copywriting-guidelines</a> 以及我的个人偏好，将本博客的 Markdown 文件书写规则做一点说明，有冲突时优先考虑下文的规则。</p>
<ul>
<li>标点符号<ul>
<li>中文内容不掺杂半角标点符号，英文内容不掺杂全角标点符号</li>
<li>中文内容使用全角直角引号代替全角双引号</li>
<li>数字内容使用半角字符</li>
<li>不使用重复的标点符号，「...」除外</li>
<li>内容必须以标点符号结尾，表格、列表、代码除外</li>
</ul>
</li>
<li>空格<ul>
<li>中英文之间留空格，（按照官方格式书写）</li>
<li>中文与数字、数字与单位（「°」「℃」「%」等除外）之间留空格</li>
<li>全角标点符号前后不留空格</li>
<li>省略号「……」后留一个空格</li>
</ul>
</li>
<li>名词<ul>
<li>「豆瓣FM」等同时包含中英文的产品名词按照官方格式书写</li>
<li>专有名词使用官方格式的大小写和缩写</li>
</ul>
</li>
<li>Markdown<ul>
<li>Markdown 语法优先于 HTML 标签</li>
<li>Markdown 标题从 <code>##</code> 开始，按内容相关度分段</li>
<li>Markdown 语法与前后正文内容之间留一个空格，全角标点符号除外</li>
</ul>
</li>
<li>其他<ul>
<li>指示流程的内容按「Step A -&gt; Step B -&gt; Step C」格式书写</li>
<li>指示代码行号的内容按「LNUM [-ENDNUM]」格式书写</li>
<li>引用拥有个人主页、博客或 GitHub 账号的人员名称按「@NICKNAME」格式书写</li>
<li>引用 GitHub 的仓库名称按「@USER/REPO」格式书写</li>
<li>引用文献的名称按「原标题 - 来源」格式书写并将链接包含在全角书名号之内</li>
<li>段落中阐述代码用到的「变量名称」「函数名称」等按行内代码块格式书写</li>
<li>段落中非阐述代码用到的且需要强调的内容使用直角引号包围</li>
<li>段落中文件名、文件路径、文件名后缀等内容按行内代码块格式书写</li>
<li>文章正文内各级标题要意义明确、格式一致、保持简洁，不多于两层标题嵌套</li>
<li>文章中表示个人想法、从别处摘抄的内容按照引用格式书写</li>
<li>文章直接引用到正文的内容不符合本站规则的地方需要进行适当调整</li>
<li>文章中引用的、可能存在争议的内容在脚注中进行说明</li>
</ul>
</li>
</ul>
<p>除去这些规定，在文章的分类和标签上我也相较原来的 Typecho 博客做了些精简。分类目前想法是只保留 <a href="https://blog.monsterx.cn/category/life">life</a> <a href="https://blog.monsterx.cn/category/code">code</a> <a href="https://blog.monsterx.cn/category/tech">tech</a> 三类，分别用来保留筛选后关于「记录生活的手帐、站点杂务」「写代码的探索和思考」「学习某些技术、使用轮子的日志」的内容。每篇文章的标签保持精简，写完整篇文章后提取两到三个关键词作为标签。</p>
<p>做完这些剩下的就是提升自身水平了……</p>
<h2 id="keep-moving">Keep moving...</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从零开始的追番生活]]></title>
        <id>https://blog.monsterx.cn/tech/auto-download-bangumi-with-aria2-rss/</id>
        <link href="https://blog.monsterx.cn/tech/auto-download-bangumi-with-aria2-rss/"/>
        <updated>2020-07-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>最近觉得为了偶尔看看电影动漫而续费腾讯视频会员太吃亏了，一个月四集的《斗罗大陆》水得不行啊喂！哔哩哔哩大会员也是如此，有的时候我在这头，想看的番剧在那头，每次都要科学上网才能解锁，属实费劲。</p>
<p>想了想自己闲置的服务器和最近开通的 Microsoft 365 E5 开发者订阅，我决定自己动手，部署一套更省钱的追番流程。最初是这样一套笨笨的追番流程：「bangumi.moe 等种子站找资源 -&gt; 服务器 Aria2 下载 -&gt; Rclone + Aria2 联动将内容转移到云盘 -&gt; 云盘网页下载」。但是这样一来科学上网工具的流量开销比较大，而且也完全称不上自动。后来我发现 Windows 系统打开 OneDrive 文件夹同步就可以免去手动登录网页下载，于是我从之前的 Google Drive 迁移到 OneDrive，这样一来流程的后两步就合并了。如何让前两步合并呢？一番搜索之后我找到了 FlexGet 这个 Python 编写的工具，众多插件使得 FlexGet 在 RSS 订阅下载上大放异彩。本文便记录这一部署过程。</p>
<h2 id="rclone">Rclone</h2>
<p>Rclone 用于网盘挂载，从 <a href="https://rclone.org/downloads/">官方</a> 下载安装，按照命令行提示输入后得到配置文件 <code>rclone.conf</code>（后续使用），路径一般为 <code>~/.config/rclone/rclone.conf</code>。</p>
<p>注意使用自己的 Secret ID &amp; Key，据说能极大的提高文件传输速率。公用的 API 想想就知道肯定比不过自建。参考文档《<a href="https://rclone.org/drive/#making-your-own-client-id">GoogleDrive: Making your own client_id - rclone.org</a>》《<a href="https://rclone.org/onedrive/#getting-your-own-client-id-and-key">OneDrive: Getting your own Client ID and Key - rclone.org</a>》创建即可。</p>
<p>Rclone 挂载 OneDrive 时需要在运行图形界面的系统上完成。Linux 服务器由于一般不带图形界面，所以需要配合本地机器：在 Windows 中下载 Rclone 相应版本文件，Power Shell 进入解压后的文件夹中键入下面命令后复制 <code>Paste the following into your remote machine ---&gt;</code> 和 <code>&lt;---End paste</code> 之间的 <code>SECRET_TOKEN</code> 到远程服务器命令行中。</p>
<pre><code class="language-powershell">.\rclone authorize &quot;onedrive&quot; &quot;Client_ID&quot; &quot;Client_secret&quot;
</code></pre>
<p>OneDrive 更详细挂载过程可参考文章《<a href="https://p3terx.com/archives/rclone-connect-onedrive-with-selfbuilt-api.html">Rclone 进阶使用教程 - 自建私有 API 挂载 OneDrive - P3TERX</a>》。<strong>后面均使用 OneDrive 部署</strong>。</p>
<h2 id="aria2">Aria2</h2>
<p>Aria2 是一个强大的下载工具，这里使用 Docker 部署 Aria2 后端服务和 AriaNG 前端页面。参考文章《<a href="https://p3terx.com/archives/docker-aria2-pro.html">Aria2 Pro - 更好用的 Aria2 Docker 容器镜像 - P3TERX</a>》。</p>
<pre><code class="language-bash"># 建立 Docker 映射文件夹
mkdir /data /data/ariapro /data/ariapro/config /data/ariapro/downloads

# 复制 Rclone 配置文件
cp ~/.config/rclone/rclone.conf /data/ariapro/config/rclone.conf

# 部署 p3terx/aria2-pro 镜像
# 修改 &lt;TOKEN&gt; 为自定字符串
# 若支持 IPv6 则开启 IPV6_MODE=enable 否则需要关闭
docker run -d \
  --name ariapro \
  --restart unless-stopped \
  --log-opt max-size=1m \
  --network host \
  -e PUID=$UID \
  -e PGID=$GID \
  -e RPC_SECRET=&lt;TOKEN&gt; \
  -e RPC_PORT=6800 \
  -e LISTEN_PORT=6888 \
  -e IPV6_MODE=enable \
  -e SPECIAL_MODE=rclone \
  -v /data/ariapro/config:/config \
  -v /data/ariapro/downloads:/downloads \
  p3terx/aria2-pro

# 部署 p3terx/ariang 镜像
docker run -d \
  --name ariang \
  --restart unless-stopped \
  --log-opt max-size=1m \
  -p 6880:6880 \
  p3terx/ariang

# 配置 rclone 自动上传
# 根据实际修改网盘名称 drive-name 和网盘路径 drive-dir
nano /data/ariapro/config/script.conf
# 修改下载完成后执行的命令 on-download-complete 为 /root/.aria2c/upload.sh
nano /data/ariapro/config/aria2.conf

# 重启 Aria2 容器
docker restart ariapro
</code></pre>
<h2 id="nginx">Nginx</h2>
<p>由于使用 IP 登录不太方便，所以继续部署 Nginx 服务反向代理 RPC 端口、绑定自己的域名。简便起见，直接使用 Ubuntu 仓库中的 nginx 包。如果服务器中已安装 Nginx，则直接新建配置文件。</p>
<pre><code class="language-bash">apt install -y nginx
</code></pre>
<p>安装好后 Nginx 配置文件位于 <code>/etc/nginx</code>，于 <code>/etc/nginx/conf.d</code> 文件夹下新建 <code>.conf</code> 文件：</p>
<details><summary><strong>Nginx 配置文件</strong></summary><br />


<pre><code class="language-nginx">server {
  listen [::]:80;                       # 若支持 IPv6 则启用
  listen 80;
  listen [::]:443 ssl http2;            # 若支持 IPv6 则启用
  listen 443 ssl http2;
  ssl_certificate /path/to/.crt;        # .crt 证书文件路径
  ssl_certificate_key /path/to/.key;    # .key 证书文件路径
  ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3;
  ssl_ciphers TLS13-AES-256-GCM-SHA384:TLS13-CHACHA20-POLY1305-SHA256:TLS13-AES-128-GCM-SHA256:TLS13-AES-128-CCM-8-SHA256:TLS13-AES-128-CCM-SHA256:EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;
  ssl_prefer_server_ciphers on;
  ssl_session_timeout 10m;
  ssl_session_cache builtin:1000 shared:SSL:10m;
  ssl_buffer_size 1400;
  add_header Strict-Transport-Security max-age=15768000;
  server_name www.example.com;          # 域名
  access_log off;
  if ($ssl_protocol = &quot;&quot;) { return 301 https://$host$request_uri; }
  
  location / {
    proxy_redirect off;
    proxy_pass http://localhost:6880;     # 修改为 ariang 端口
    proxy_set_header  Host                $http_host;
    proxy_set_header  X-Real-IP           $remote_addr;
    proxy_set_header  X-Forwarded-Ssl     on;
    proxy_set_header  X-Forwarded-For     $proxy_add_x_forwarded_for;
    proxy_set_header  X-Forwarded-Proto   $scheme;
    proxy_set_header  X-Frame-Options     SAMEORIGIN;
    client_max_body_size        100m;
    client_body_buffer_size     128k;
    proxy_buffer_size           4k;
    proxy_buffers               4 32k;
    proxy_busy_buffers_size     64k;
    proxy_temp_file_write_size  64k;
  }
  location ^~ /jsonrpc {
    proxy_http_version 1.1;
    add_header Front-End-Https on;
    proxy_set_header Connection &quot;&quot;;
    proxy_set_header Host $http_host;
    proxy_set_header X-NginX-Proxy true;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    # 修改为 p3terx/aria2-pro 容器 RPC_PORT
    proxy_pass http://localhost:6800/jsonrpc;
    proxy_pass_header X-Transmission-Session-Id;
  }
  # 多个 aria2 后端示例
  # location ^~ /googlejsonrpc {                # 修改
  #   proxy_http_version 1.1;
  #   add_header Front-End-Https on;
  #   proxy_set_header Connection &quot;&quot;;
  #   proxy_set_header Host $http_host;
  #   proxy_set_header X-NginX-Proxy true;
  #   proxy_set_header X-Real-IP $remote_addr;
  #   proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  #   proxy_pass http://localhost:6802/jsonrpc; # 修改
  #   proxy_pass_header X-Transmission-Session-Id;
  # }
}
</code></pre>
</details><br />


<p>修改上方例子中的域名、端口即可。多个 Aria2 RPC 端口时可以参考注释掉的部分。最后重启 Nginx。</p>
<pre><code class="language-bash">service nginx restart
# nginx -s reload
</code></pre>
<h2 id="rss">RSS</h2>
<p>部署 FlexGet 之前当然是先找支持 RSS 订阅的站点！目前我个人觉得萌番组的体验还不错！<a href="https://bangumi.moe">萌番组官网</a> / <a href="https://bangumi.moe/lite">萌番组 Lite 版官网</a> / <a href="https://bgm.ptr.moe">萌番组 Material Design 版</a>。点击搜索图标添加 Tags 搜索后 RSS 图标链接地址即为可用订阅地址，切换标题搜索同理。</p>
<p>比如 添加标签「Lilith-Raws」「租借女友」「1080p」和搜索标题「Lilith 賢者時間 1080p」分别可以得到这两种 RSS 订阅地址：</p>
<pre><code>https://bangumi.moe/rss/tags/5d8b3245306f1a0007bd7aca+548ee2ce4ab7379536f56358+5efffb4f3d656e43622cacc9
https://bangumi.moe/rss/search/Lilith%20%E8%B3%A2%E8%80%85%E6%99%82%E9%96%93%201080p
</code></pre>
<p>除了 bangumi.moe 之外还有很多平台，部分资源相同，罗列一些包括但不限于二次元的资源站：</p>
<ul>
<li>BT RSS 订阅<ul>
<li><a href="https://share.dmhy.org">動漫花園資源網</a> 动漫、日剧、游戏、特摄等</li>
<li><a href="https://acg.rip">ACG.RIP</a> 动画、日剧、综艺、音乐等</li>
<li><a href="https://bt.xfsub.org">旋风动漫分享站</a> 漫画</li>
<li><a href="https://nyaa.si">Nyaa</a> 侧重于东亚（中日韩）多媒体资源，被日本政府确定为主要的数字盗版网站</li>
<li><a href="https://yts.mx">YIFY</a> 以 BitTorrent 分发大量免费下载的电影而闻名，国内很多电影资源源头</li>
<li><a href="https://eztv.io">EZTV</a> 国外电视节目等，「TV Torrents Online Series Download」</li>
<li><a href="https://thepiratebay10.org/">The Pirate Bay 10</a> 据称是「the galaxy&#39;s most resilient BitTorrent site」</li>
<li><a href="http://f.cili001.com/home.html">MAG 磁力站</a> 侧重影视剧集，可以搜人人影视专用链接</li>
</ul>
</li>
<li>字幕<ul>
<li><a href="https://bbs.vcb-s.com/forum-37-1.html">VCB-S 分享论坛</a> ACG 字幕分享</li>
<li><a href="https://subhd.tv/">SubHD.tv</a> 资源+字幕站，找字幕体验非常好</li>
<li><a href="http://www.zmtiantang.cc">字幕天堂</a></li>
</ul>
</li>
<li>漫画<ul>
<li><a href="http://www.animetox.com">Animex 动漫社</a> 最近找进击的巨人漫画发现的</li>
<li><a href="http://mangabz.com">Māngabz</a> 在线漫画阅读</li>
<li><a href="https://www.dmzj.com">动漫之家</a></li>
<li><a href="https://www.omyschool.com">木马漫画</a></li>
</ul>
</li>
</ul>
<h2 id="flexget">FlexGet</h2>
<p>以上部分搭建了基础的下载环境，接下来利用 FlexGet 实现 Aria2 的 RSS 订阅下载。</p>
<blockquote>
<p>FlexGet is a multipurpose automation tool for all of your media <br />
Support for torrents, nzbs, podcasts, comics, TV, movies, RSS, HTML, CSV, and more.  [^1]</p>
</blockquote>
<p>由于是 Python 编写，需要先安装 python3 pip3 包。</p>
<pre><code class="language-bash">apt install python3 python3-pip
pip3 install --upgrade pip setuptools
pip3 install flexget
</code></pre>
<p>安装完成后新建 FlexGet 配置文件夹并编写配置文件。</p>
<pre><code class="language-bash">mkdir -p ~/.config/flexget
nano ~/.config/flexget/config.yml
</code></pre>
<details><summary><strong>FlexGet 配置文件</strong></summary><br />


<pre><code class="language-yaml">schedules:
  - tasks: &quot;*&quot;
    schedule:
      hour: &quot;*/2&quot;

tasks:
  KanojoOkarishimasu:
    rss: https://bangumi.moe/rss/tags/5d8b3245306f1a0007bd7aca+548ee2ce4ab7379536f56358+5efffb4f3d656e43622cacc9
    accept_all: yes
    aria2:
      server: localhost
      port: 6800
      secret: &lt;TOKEN&gt;
      path: /租借女友/
  YahariOrenoSeishunLovecomewaMachigatteIruKan:
    rss: https://bangumi.moe/rss/tags/5d8b3245306f1a0007bd7aca+548ee2ce4ab7379536f56358+5e822875657e22f4195cc78c
    accept_all: yes
    aria2:
      server: localhost
      port: 6800
      secret: &lt;TOKEN&gt;
      path: /我的青春恋爱物语果然有问题.完/
  DouLuoDaLu:
    rss: https://bangumi.moe/rss/search/GM-Team%20%E6%96%97%E7%BD%97%E5%A4%A7%E9%99%86%201080p
    accept_all: yes
    aria2:
      server: localhost
      port: 6800
      secret: &lt;TOKEN&gt;
      path: /斗罗大陆/
  Japan4KAnimeYTSMX:
    rss: https://yts.mx/rss/0/2160p/animation/0/ja
    accept_all: yes
    aria2:
      server: localhost
      port: 6800
      secret: &lt;TOKEN&gt;
      path: /YTS.MX.Japan4KAnime/
</code></pre>
</details><br />


<p>注意修改 Aria2 后端端口和 Secret。保存后手动运行测试一次，选一种模式设置定时任务，查看状态。</p>
<pre><code class="language-bash">flexget --test execute

flexget status

# Daemon 模式定时任务
#  -d                     后台运行
#  --autoreload-config    执行前重新载入配置文件
@reboot /usr/local/bin/flexget daemon start -d --autoreload-config

# Crontab 模式定时任务
# 删掉前面配置文件中的 scheduler 块配置
# 使用偏好的编辑器进入，添加一行
crontab -e
*/30 * * * * /usr/local/bin/flexget --cron execute
</code></pre>
<p>关于定时任务，上方示例中开头 L1-4 的配置使用了 scheduler 插件，只有在 Daemon 模式下才可用。使用 crontab 定时任务不需要该配置。</p>
<h2 id="local">Local</h2>
<p>最后一步，在本地登录 OneDrive 账号设置同步文件夹。右键将本地文件夹标记为「始终在此设备上保留」即可，当云端存入新的文件时本地就会自动下载同步。删除本地文件夹时，默认会将 OneDrive 云端文件一同删除，只删除本地需要右键选择「释放空间」。</p>
<p>白嫖的开发者订阅 OneDrive 服务器位于境外，从服务器 Rclone 上传文件速度很好，但是有人说本地下载速度太慢，这无法避免。如果使用世纪互联版 OneDrive 本地下载速度肯定会好很多，但服务器上传想必会慢些，自行权衡吧。我使用几周以来尚且满意，睡一觉起来想要看的东西就会自己出现在那里，宅の生活质量提升了，人也变得精神了呢！</p>
<h2 id="end">End</h2>
<p>关于部署上面流程的服务器强烈推荐使用国外的，国内的服务器网络带宽、Docker 部署、BT 下载环境一言难尽。我用的是 Digital Ocean 新加坡服务器，体验良好。如果就看看新番、一集一集下硬盘需求不是很高，20-40 GB 应该就可以了，要拿来正儿八经下东西硬盘还得越大越好的，这几天下的紫罗兰 4K 版全集就有 43 GB 了。本想着部署「省钱」的追番流程，结果下载服务器一个月就花了几十刀，害，钱还是得花！</p>
<p>另外安利一个微软收购的文件转移工具：<a href="https://mover.io/">Mover</a> 安全、强大、快速的文件转移工具，Microsoft 365 用户福音，可以实现 Box，Dropbox，Google，Amazon，Office 365（原 Microsoft 365） 向 Microsoft 365 转移文件，并且支持定时任务！</p>
<ul>
<li>现成的 OneDrive 文件：<a href="https://monstx-my.sharepoint.com/:f:/g/personal/storage_tingle_dev/EkM5OfD1nrZBr_214_JmLtgBNz05mQMNqIEFsZOb9FIMBg%EF%BC%9Fe=EM2tX5">Anime</a> / <a href="https://monstx-my.sharepoint.com/:f:/g/personal/storage_tingle_dev/EozDcDrM7edEpnZmeL1dDQABZg0xhZNUvnj7IvBlHKM6YA%EF%BC%9Fe=M944ih">Movies</a> / <a href="https://monstx-my.sharepoint.com/:f:/g/personal/storage_tingle_dev/ErcXo0q92thGqrbkpzurmI8BOXwGMJgP0AiwB5lZa_cvuw%EF%BC%9Fe=SM2cWU">Series</a></li>
<li>部分境外服务器可能禁止 BT 服务，选购前请仔细阅读用户条例</li>
<li>有条件的话下载完毕后请做种一段时间</li>
</ul>
<center><span style="font-size:30px">微软赛高！</span></center>


<p>[^1]: <a href="https://flexget.com/">FlexGet Official website</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[照葫芦画瓢 · 编写 Actions 打卡工作流]]></title>
        <id>https://blog.monsterx.cn/tech/modified-github-actions-4-heu-checkin/</id>
        <link href="https://blog.monsterx.cn/tech/modified-github-actions-4-heu-checkin/"/>
        <updated>2020-06-30T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>昨天逛博客看到了使用 GitHub Actions 定时调用 Microsoft 365 E5 API 以帮助续订的文章，我转念一想这是不是也可以用来跑定时任务打卡呢？说干就干我开了一个小的坑：用 GitHub Actions 跑之前写的 Python 打卡脚本。无意薅羊毛，只是希望通过一点学习将自己的想法实现。</p>
<h2 id="照葫芦环节">照葫芦环节</h2>
<p>参考项目 <a href="https://github.com/wangziyingwen/AutoApiSecret">@wangziyingwen/AutoApiSecret</a> 的 <a href="https://github.com/wangziyingwen/AutoApiSecret/blob/master/.github/workflows/autoapi.yml">autoapi.yml</a>，搞懂了这一流程：</p>
<ol>
<li>将私密信息存于仓库 Secrets，以 <code>name=value</code> 的赋值语句格式定义</li>
<li>将 Secrets 内容写入脚本复制来的临时文件</li>
<li>执行填入了 Serects 的临时文件</li>
<li>删除所有临时文件并提交历史记录</li>
</ol>
<p>「定时」这一特性是 GitHub Actions 提供的，在触发条件中定义 <code>on.schedule.cron</code> 即可！呐噜吼多！将 Secrets 写入文件是通过 Linux 命令 <code>sed</code> 实现的，比如使用 <code>sed -i &#39;10 r tmp.txt&#39; tmp.py</code> 可以将 <code>tmp.txt</code> 的内容写入了 <code>tmp.py</code> 的指定行 <code>10</code> 的下一行。对 Linux 命令的认知水平停留在 <code>rm -rf</code> 的我大吃一惊，呀，又学到了新知识！</p>
<h2 id="画瓢环节">画瓢环节</h2>
<p>此刻，白嫖是第一生产力。了解了这样的流程部署自己的自动打卡（让 GitHub 定时执行 <code>python checkin.py</code>）就不是什么难事了。</p>
<details><summary><strong>照葫芦画瓢 python.yml 第一版</strong></summary><br />


<pre><code class="language-yaml">name: Auto Checkin

on: 
  release:
    types: [published]
  # Coordinated Universal Time (UTC)
  schedule:
    - cron: &#39;0 0 * * *&#39;           # 定时任务实现方式
  watch:
    types: [started]

jobs:
  build:
    runs-on: ubuntu-latest
    if: github.event.repository.owner.id == github.event.sender.id  # 仅自己点的 star 触发
    steps:
      - name: Checkout
        uses: actions/checkout@master

      - name: Python Setup
        uses: actions/setup-python@v1
        with:
          python-version: 3.8

      - name: Pip Cache             # 按照官方仓库 @actions/cache 添加
        uses: actions/cache@v2
        with:
          path: ~/.cache/pip        # Ubuntu 的缓存位置，不同系统不同位置需要修改
          key: ${{ runner.os }}-pip-${{ hashFiles(&#39;**/requirements.txt&#39;) }}
          restore-keys: ${{ runner.os }}-pip-
      
      - name: Addons Install        # 安装脚本必须组件 lxml requests
        run: pip install lxml requests
      
      - name: Secrets Get           # 获取 Secrets
        env: 
          SECRET_ID: ${{ secrets.SECRET_ID }}
          SECRET_PASS: ${{ secrets.SECRET_PASS }}
          SECRET_BOUND: ${{ secrets.SECRET_BOUND }}
          SECRET_DATA: ${{ secrets.SECRET_DATA }}
        # 先复制一个临时文件，然后写入 Secrets 到文本，再将其写入临时脚本文件指定行
        run: | 
          cp checkin.py action.py
          echo $SECRET_ID &gt; action-id.txt
          echo $SECRET_PASS &gt; action-pass.txt
          echo $SECRET_BOUND &gt; action-bound.txt
          echo $SECRET_DATA &gt; action-data.txt
          sed -i &#39;19 r action-id.txt&#39; action.py
          sed -i &#39;20 r action-pass.txt&#39; action.py
          sed -i &#39;21 r action-bound.txt&#39; action.py
          sed -i &#39;22 r action-data.txt&#39; action.py
      
      - name: Checkin Action
        env:
          TZ: Asia/Shanghai         # 设定时区为北京时间
        # 工作流过程中新建 log 文件夹存放待会发布到另外一个分支的内容
        run: | 
          mkdir log
          echo `date +&quot;%Y-%m-%d %H:%M:%S %A&quot;` &gt;&gt; log/time.log
          python action.py &gt;&gt; log/time.log
      
      - name: Secrets Delete        # 删除临时文件
        run: rm -f action*
      
      - name: Deploy Log            # 发布 log 文件夹下的记录文件到 log 分支
        uses: docker://peaceiris/gh-pages:v2
        env:
          TZ: Asia/Shanghai
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PUBLISH_BRANCH: log
          PUBLISH_DIR: ./log
        with:
          emptyCommits: false
</code></pre>
</details><br />


<p>第一版的工作流程看起来有点臃肿，不过管他呢，能用。</p>
<h2 id="润色">润色</h2>
<p>写完第一份工作流文件之后，我开心地将文件提交到了 GitHub 仓库，又煞有介事地写了份文档。但是坐下来反复看自己的代码之后，我越发觉得这过于粗糙。在博客的文章收到了大佬的指导，于是我有了新的思路并开始不断地给自己的代码「润色」。</p>
<h3 id="round-1">Round 1</h3>
<p>简单地实现定时任务似乎并不值得记录，于是我顺便给这个工作流引入了 pip 模块缓存、发布日志文件到分支这两个小功能，算是补上了之前折腾工作流学到的。</p>
<ul>
<li><p><strong>pip 模块缓存</strong></p>
<p>这是从苏卡大大《<a href="https://blog.skk.moe/post/deploy-blog-to-cf-workers-site">将 Hexo 部署到 Cloudflare Workers Site 上的趟坑记录 - Sukka&#39;s Blog</a>》中学到的。Node.js 项目构建时需要的依赖挺多，没有缓存的话每次 GitHub Action 得跑很长分钟，于是他给出了缓存 node_modules 的办法： <code>uses: actions/cache@v2</code> ，通过检查缓存特征 Key 是否存在，比如 Node.js 就检测是否存在 <code>package-lock.json</code> 文件，进而处理缓存。</p>
<p>GitHub Actions 使用这一特性其实很简单，只要按照 <a href="https://github.com/actions/cache">@actions/cache</a> 中需要缓存的类型确定好监测的特定路径和文件，编写类似上方 L26-31 的步骤在安装依赖前即可。之前尝试是能将用于构建并发布站点的 2 mins 工作流优化到 1 min 多，提升还是蛮大的。</p>
<p>在这个项目中缓存 pip 模块需要做的就是照葫芦画瓢检查 <code>~/.cache/pip</code> 目录下 <code>requirements.txt</code> 文件。</p>
</li>
<li><p><strong>发布 log 记录文件到分支</strong></p>
<p>这是从 Typecho-Theme-VOID 二次开发过程中学到的。它的 Actions 将编译好的文件存放在 build 文件夹然后发布到 nightly 分支。仅需在 workflows 中给 <code>uses: docker://peaceiris/gh-pages:v2</code> 添加两个环境变量 <code>PUBLISH_BRANCH</code> 和 <code>PUBLISH_DIR</code> 即可，v3 版本这一配置从 <code>env</code> 改为了 <code>with</code> 字段，具体可以看 <a href="https://github.com/peaceiris/actions-gh-pages">@peaceiris/actions-gh-pages</a>。</p>
</li>
<li><p><strong>邮件</strong></p>
<p>启用 GitHub Actions 后我将 Python 中的 SMTP 配置删除了，这原本是用来在服务器部署时完成任务后发送提醒的。我想只要开启 GitHub 工作流的运行提醒就好啦，后来意识到虽然 GitHub Actions 自身有邮件提醒，但它提醒的是工作流执行状况，并不能等价于打卡脚本的执行状态。这一点还有待优化。毕竟配置起来如果像上面一样一条一条添加 Secrets 的话就太繁琐了。</p>
</li>
<li><p><strong>微信提醒</strong></p>
<p>由于 GitHub Actions 部署邮件提醒不方便，我找到了微信提醒的工具 Server 酱，在 Python 中使用 requests 库发送请求即可触发微信提醒，结合程序执行结果可以更加完美的推送打卡提醒；Ruby 不会写，我就直接从 Actions 执行时由命令行 <code>curl</code> 发送请求了，这些代码十分粗糙，放在了仓库 personal 分支下。</p>
</li>
</ul>
<h3 id="round-2">Round 2</h3>
<p>也许看官早就想说了：为什么引用 Secrets 而已，又是设置环境变量、又是将环境变量 <code>echo</code> 到 <code>.txt</code> 文件、又是将 <code>.txt</code> <code>sed</code> 写入 <code>.py</code> 的，不能简单点吗？确实，在朋友 <a href="https://xyenon.bid">@XYenon</a> 的指导下我得知 Python 可以通过 <code>os.environ</code> 读取环境变量，所以简单的办法来了，将 Python 脚本中原来的赋值改写成下面的格式直接读环境变量</p>
<pre><code class="language-python">import os

myid = os.environ [&#39;SECRET_ID&#39;]
</code></pre>
<p>直接读入环境变量 <code>SECRET_ID</code> 的值并赋给 <code>myid</code> 。如此一来，上面 Secrets Get、Checkin Action、Secrets Delete 三步合并为一步：</p>
<pre><code class="language-yaml">- name: Action Execute
  env:
    TZ: Asia/Shanghai
    SECRET_ID: ${{ secrets.SECRET_ID }}
    SECRET_PASS: ${{ secrets.SECRET_PASS }}
    SECRET_BOUND: ${{ secrets.SECRET_BOUND }}
    SECRET_DATA: ${{ secrets.SECRET_DATA }}
  run: python checkin.py | tee -a checkin-python.log
</code></pre>
<p>心情顿时舒畅了不少！</p>
<h3 id="round-3">Round 3</h3>
<p>上次那篇关于调试 Python 打卡的《<a href="https://blog.monsterx.cn/code/heu-auto-checkin-covid19/">Mark 并调试 HEU 自动打卡代码</a>》下 <a href="https://xyenon.bid">@XYenon</a> 给出了仅需用户名和密码的 Ruby 版本 <a href="https://gist.github.com/XYenon/79317d63e7f769e5bdff5b595d709b65">@XYenon/checkin.rb</a>。</p>
<p>代码仅 60 行，第一次看完我觉得很赞，看起来只要脚本代替人执行「确认信息 -&gt; 提交表单」两步就完事了。现有的 Python 打卡每次都将事先定义的表单数据提交一遍，不考虑打卡系统中表单在服务器的缓存。如果表单数据在服务器上一直都有缓存，那部署这个 Ruby 版本我觉得似乎会更好，毕竟仓库里可以少写两个 Secrets。</p>
<blockquote>
<p>与 Python 类似，Ruby 也可以在代码中使用 <code>ENV[&#39;SECRET_ID&#39;]</code> 这样的语句直接获取环境变量。</p>
</blockquote>
<p>实际调试的时候，我发现这看起来简单的代码部署起来也不容易…… Ruby 使用 webdrivers 库来在终端驱动一个 headless Chrome 浏览器，然后执行动作。抛开因为不熟悉 Ruby + webdrivers 这套环境使我在 GitHub Actions 工作流写法上花的时间，这个脚本跑起来效率也比较低，Python 直白地提交表单整个工作流程需要 30 秒左右，而 Ruby 模拟 Chrome 操作花了三分钟多。是为了更快的 workflow 选择 Python 打卡呢？还是为了更快的部署选择 Ruby 打卡呢？</p>
<p>经过多方搜索我使用了这样的 GitHub Actions 环境跑 Ruby + Watir + webdrivers 代码，不知道有没有更好的方式，贴在这里供大家参考：</p>
<pre><code class="language-yaml">jobs:
  build:
    runs-on: ubuntu-latest
    # 运行 headless chrome 的服务
    services:
      hub:
        image: selenium/hub:3.141.59-gold
        env:
          SELENIUM_HUB_HOST: localhost
      chrome:
        image: selenium/node-chrome:3.141.59-gold
        env:
          HUB_HOST: localhost
          HUB_PORT: 9515
    
    if: github.event.repository.owner.id == github.event.sender.id
    steps:
      - name: Checkout
        uses: actions/checkout@master
      
      - name: Ruby Setup
        uses: actions/setup-ruby@v1
        with:
          ruby-version: 2.5.x
      
      - name: Addons Install
        run: gem install watir webdrivers
      
      - name: Action Execute
        env:
          TZ: Asia/Shanghai
          LANG: zh_CN.UTF-8
          SECRET_ID: ${{ secrets.SECRET_ID }}
          SECRET_PASS: ${{ secrets.SECRET_PASS }}
        run: ruby checkin.rb | tee -a checkin-ruby.log
</code></pre>
<blockquote>
<p>也许 Ruby 版本的打卡程序更适合写成 JavaScript 用户脚本交给浏览器插件执行。</p>
</blockquote>
<h2 id="结语">结语</h2>
<p>GitHub 仓库地址 <a href="https://github.com/monsterxcn/HEU-Checkin-COVID-19">@monsterxcn/HEU-Checkin-COVID-19</a>。如果仓库说明仍未找到你需要的部署过程，可以参考以下我的另外一篇文章《<a href="https://blog.monsterx.cn/code/heu-auto-checkin-covid19/">Mark 并调试 HEU 自动打卡代码</a>》</p>
<p>我原以为在 GitHub Actions 中实现定时任务要很复杂的配置，毕竟每次工作流都是相当于在一个全新的服务器上执行。现在发现原来定时任务只需要在工作流的触发事件中写入 <code>schedule</code> 即可。在查找文档时我发现这点在官方文档中有详细说明，害，都是不会看文档惹的祸。</p>
<p>榆木脑袋的我在看到别人的代码之前总是从没想过可以这样实现。比如：将私密信息以赋值语句形式写入仓库设置，执行 GitHub Actions 时将赋值语句插进文件头部继续执行。甚是高明（虽然到后面我发现这也挺笨的）。剖析了我的不足之处，浅层来看最重要的两点估计就是：</p>
<ul>
<li>我对仓库 Secrets 设置的认识是死板的，我一直将其当作 GitHub Actions 执行时传递普通变量值的纽带，仅此而已</li>
<li>不熟悉 Linux命令，虽然日常 Copy 到命令行的 Linux 命令中也有用到过 <code>sed</code>，但我并没有积极的学习</li>
</ul>
<p>深层次的原因嘛，大概是怠惰吧！</p>
<p>GitHub Actions 妙用多多，之前关注过一个博客 <a href="https://p3terx.com/">@P3TERX ZONE</a> 里写了挺多关于 GitHub Actions 的文章，有时间的话要去学习学习！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[手帐 · 常]]></title>
        <id>https://blog.monsterx.cn/life/daily-impermanence/</id>
        <link href="https://blog.monsterx.cn/life/daily-impermanence/"/>
        <updated>2020-05-18T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>最近的日子过得忙碌，五味杂陈。这种状态持续了多久呢……</p>
<h2 id="生活">生活</h2>
<p>大概疫情开始后我的生活就变了吧，刚开始时是铺天盖地的谣言与辟谣，以及每日新增的新闻，我想：像我这种从不门、连屋子都懒得出去的人来说唯一能让我动弹的只有快递和外卖，而现在只剩快递。心里默默计划的返校从 4 月拖到 5 月，眼下看来还要继续拖到 6 月，而原本计划返校再做的一些事不得不在家里完成，比如补考。嗯，在家学习的感觉不算太差也不算太好，前半句是因为我不再需要从众，没必要做样子给谁看；后半句则是因为在家也免不了走神，课上着上着就想到了浏览器，今天 Feedly 的朋友们又整什么活了吗 / GayHub 的朋友们又发现了什么新奇玩意儿吗？</p>
<p>也许让疫情背锅也不对，从安卓换到苹果之后生活改变了许多。自从一加 5 不再工作，我换上了一年前买给妈妈备用的 iPhone 6s，在这个三摄四摄呼风唤雨、苹果华为针尖麦芒的时代，手里握着这轻巧的 6s 可谓复古了。折腾了许久，翻越高墙的梦想还是不能在 6s 上实现，想了想被我刷成白苹果的 i7 我还是不再考虑瞎折腾了，翻什么翻？憋着！用惯了 Android 的我看来 iOS 还是不适合我，最让我头疼的是复制文件居然还必须走 iTunes，啊这？也许正是这些不习惯，让我戒掉了对手机的过度依赖，然后，转向了对电脑的过度依赖。在家有网有电，不像在宿舍玩到正尽兴时断网断电了，我的电脑也渐渐开始像一台服务器一样工作，白天网课、浏览器、VSCode，夜晚下载、挂机、自动更新，只有我哪天突然心疼本本了才会选择让他重启。原来花在手机游戏上的时间开始成为我瞎折腾的资本，这段时间除了上网课的时间我几乎都花在了浏览网页和写 Bug 上。重拾 C 语言，看看 Python，学学 CSS 和 JavaScript，想干啥就干啥，不像在宿舍。在宿舍里写代码有一种异类的感觉，我更希望大家在寝室一起联机快乐，而不是我在做着他们都不理解的事情然后他们发出不明所以的吹捧「牛逼啊」。</p>
<p>又或者这一切既不是因为疫情，也不是因为手机电脑，而是因为身边的人和事。今年过年的时候格外冷清，我觉得似乎上了大学之后这样的年就成为常态了，不像以前叔伯姨舅都会回家团聚，今年刚好就着疫情的由头谁也不回了，大年夜只剩一家五口围着咕嘟嘟冒泡的清汤火锅抿一口健康的王老吉，清心寡欲。二姑走了很多年了，家里人一直瞒着爷爷，刚开始的时候我看着父母亲朋在饭桌上编理由糊弄老人，现在爷爷似乎也不再问起，我对这事感觉很微妙。现在二姑爷也病的不轻了，我不敢想象以后的事。最近呢，舅舅也不知道什么情况住院了，从县里转到市里，妈妈不跟我说，但是我看着她时常精神不振就知道舅舅一定病得不轻。想想舅舅那么爽朗乐观的人，现在也不得不戴着呼吸机躺在病床上，这种感觉也很 <del>微妙</del> 不妙。妈妈就这件事时常警告我不要熬夜，要我早睡早起吃早饭。我也想过啊，可是有的事情成为习惯就不想改了，夜晚宁静得有种与世隔绝的感觉，做什么都不会被人打扰，没有 QQ 消息，没有微信通知，群聊变得安静，整个世界都变得清净了。这个时候开始，无论是突击作业还是敲击键盘写博文修代码，总是感觉十分舒适。哦，唯一让我头疼的就是妈妈的催促「几点啦？赶快睡觉啊」……</p>
<p>谈及生命的时候我总会想自己的未来。不知不觉大二也已经快过完了，曾经幻想中的步入社会就在眼前，可是当我走到这一步的时候却发现，我为了这一切做的事这么傻。我在父母的监督下学习，在大学的宽松下放肆，以前每天的学习就为了考一个像样的大学离开家乡，现在每天的学习就为了及格万岁。大一的时候认为这些数学物理学了又有什么用处呢？不学！现在接触了专业课才懂得什么叫「数理基础」，原来一切需要这些基础。那些年少无知的想法让现在的自己追悔莫及，一种 <em>多年的义务教育都将葬送在大学四年</em> 的想法在心底滋生。刚进入大学的时候我以自己接触了博客而自豪，现在却觉得这么多年了我的长进是那么微不足道，我总是三分钟热度学个皮毛就弃坑，而别人自学一周也许就能比我更懂 Web。身边的人就像这样默默的超越了我，只有我还活在从前。我觉得迷茫，我的人生漫无目的：未来会成为硕士吗？可是我的专业课学的一言难尽；未来会成为电气工程师吗？可是我似乎连电路仿真都做不明白；未来会成为程序员吗？可是我连前端三件套都没熟练掌握。当我否定掉这三个规划的时候，我便恐慌起来，我的人生就此失去目标了。一旦毕业我连找父母要钱的理由都没有，我从来没有考虑过如何生活。小的时候我觉得生活不过就是毕业了找份工作拿着几千一月的薪水，找个住的地方日复一日。现在看来那样的话真是糟糕透了：几千一月糊弄自己还差不多，父母呢？我有什么脸面让父母继续卖命？爱情呢？这样糟糕的糙汉子只有梦里才配拥有爱情吧？</p>
<h2 id="代码">代码</h2>
<p>太糟糕了，还是谈谈现在吧。学习之余便是代码，这一段是最近在 GitHub 上的「工作」。大约一两个月前我突然对吃灰已久的 GitHub 账号产生了想法：让 Contributions 绿起来！一直以来 GitHub 是我找资源的首选地，各种 Gist 和仓库，总是有相关的资源可以借鉴，前段时间折腾 WSL 的时候 Github issue 和 wiki 区一度成为我反复翻阅的地方，和 Stack Overflow 类似的，这里能找到大部分合适的答案。回到「工作」上来，最近做的事就是修改 VOID 主题了（顺便的还对 AlanDecode 大大的主题配套插件也动了刀，目前自己用起来是舒服了），虽然博客挺长时间没有更新了，但是对 VOID 的二次开发却一直未间断，甚至还像模像样的发布了两个小 Release。Git 的基本操作也学会一些，至少 clone commit push 一条龙算是熟练了。可惜，JavaScript 和 PHP 方面我一直都是萌新，甚至从未仔细学过他们的语法，这导致我的二次开发效率蛮低的，很多地方都是仿写，想做到没有冗余代码的地步我觉得我还有很长的路要走。本来是以为二次开发不久我就能在博客开心的宣布：VOID Done! 快来 Star 吧！结果随着二次开发的进行我越来越觉得我的代码写的实在太差劲了，为什么这个功能我做不出来？为什么这个功能要插件？现在，我连在 Alan 大佬的博客评论的勇气都没有了。（Alan：啊这？我原来写的这么工整规范的代码你给我改出个这玩意儿？）每每想到这我就一咬牙，绝对不能把这东西发博客，太 der 了！</p>
<p>真正自己做着主题维护的事情的时候，我就开始看开一些事情了。为什么开发者不回答我这个问题？我给你 5 块你把这个功能加到主题上好不好？博主博主你这个页面是怎么设置的啊？这个代码直接替换吗？换友链吗？在？…… 每天逛博客逛 GitHub 逛主题售后唠嗑群，我都能看见各种问题，至少 QQ 群里的问题层次其实都比较低，有的连问题是什么都描述不清楚。这大概是为什么 QQ 联系在程序员界算是被嫌弃的一个原因吧。被提问的人是什么感觉这因人而异，但是对我而言，我就觉得：这个问题很难吗？你自己动手试一下不好吗？同样打字的时间，你花在搜索引擎上效果比在这一两百人群只有几十个活人的地方效果更差吗？还有对于在主题售后群里聊 DD、cc、翻越高墙、散布链接的行为我更是深恶痛绝，几乎我加的每一个 QQ 主题群（从最初的 Material 到 Handsome 再到泽泽社长的群）都免不了这些。恶意攻击也偶有发生，但是链接还是会继续散布。主题售后群里时不时就丢链接的博客质量参差不齐，毫无意义的搬运不在少数。用点心思在文章上自然有人爱看，这道理很难懂吗？在这里只想借用 Alan 大佬发布 VOID 主题时的一段话：</p>
<blockquote>
<p>我希望使用这些主题的博主，能认真地多写几篇正经文章，这才是独立博客的精髓。一两句话的牢骚，大可以去微博与 Twit­ter 上说；花花绿绿的代刷广告与盗版采集还是免了吧。 [^1]</p>
</blockquote>
<p>当然，我也并不是一个优秀的博主，翻看我的归档就知道其实文章都是一些大佬看不上眼的东西，有的时候文章不删反而更容易激励自己，大概类似「反面教材」的效果。到 2024 年，如果这个博客还继续产出的话，我想必会回顾这十年的历程，从最初到当下审视博客的变化。说到十年我又想到了一个叫做「<a href="https://foreverblog.cn/">十年之约</a>」的项目，「从加入这个活动起，我们的博客十年不关闭，保持更新和活力」。对我而言，不需要任何「约定」「承诺」，我也会保持这份写博客的热情。实在是很难想象我这样一个三分钟热度的人居然坚持做博客这么多年几乎未间断！我十分期待有一天不再需要谷歌、不再需要过滤脚本，在地址栏输入中文，大家就能轻松获得详尽的中文资料。（记录一些最近发现的我觉得很棒的博客 [^2]）</p>
<h2 id="网络">网络</h2>
<p>谈及互联网内容，最近的瓜真是令人无语。什么 AO3、罗志祥、papi 酱…… 我真是搞不懂了，疫情期间闲着没事干是吗？有的事情确实挺令人恶心的，但是吃瓜归吃瓜，拿关注明星污点、翻黑料、瞎打拳的时间花在改善自己生活上不香吗？明星终究是明星，就算我拿着相机怼到人家脸上拍到了照片，咱们的世界也是截然不同的两个世界，非要说有点联系也是虚无缥缈的。</p>
<p>以前，这些明星黑料的生产商是微博，和我的世界很远；后来 QQ 有了看点，不过还好，可以关闭；现在，连哔哩哔哩也变味了。<del>我不知道是我的个人原因还是怎么了，</del> 我的哔哩哔哩她十分不像从前了。不谈每天推荐的某某正式入驻辣，连每天热门的榜单也五花八门，有的时候我刷新半天又半天都找不到一个对胃口的视频。我甚至下载了以前不屑一顾的抖音来消遣刷不到哔哩哔哩趣味的时间。</p>
<p>就我个人来看，哔哩哔哩开始走上一条悄悄远离二次元的路了，不管是公司高层的战略决策还是国家的隐形政策，她的确开始「变化」了。要说从什么时候开始有这种端倪，我觉得是央视表扬哔哩哔哩之后。舆论让哔哩哔哩越来越意识到自己其实有潜力做一个不只局限在二次元的公司，于是「变化」产生了。怎么说呢，我并没有觉得这样不好，但是就我自己看到的内容质量而言我觉得情况不太乐观。</p>
<p>说到这，我想到了哔哩哔哩弹幕的问题。弹幕弥补了视频中的不足，也拉进制作者与看官的距离，实在是高明的设计。但是低质弹幕却让人头疼，试问人们对二次元负面的一些刻板印象是从何而来？我觉得低质弹幕难辞其咎。关键词屏蔽能解决一些，但我还是希望从根源、从用户意愿上解决问题。随着社区规模的扩大，如何界定和规范用户行为，也应该成为视频平台用心考虑的问题。B 站风纪委员会希望能做得更好。哔哩哔哩的变化我觉得很大一部分都是因为涌入这个社区的人，规模扩大但不应该降低门槛，降低门槛不应该下限太低，如何找到一个平衡点让用户质量和社区热度都得到保证是一个难题。</p>
<blockquote>
<p>破案了，哔哩哔哩还是从前那个哔哩哔哩，我不是从前那个我了。</p>
</blockquote>
<h2 id="end">End</h2>
<p>写写停停，一篇普通的日记花了三个多小时，又是一次无意义的写作。</p>
<p>写完再看一遍觉得结构实在是糟糕，但是又不知道从何理出一条线索来，索性就着 Markdown 标题简单提炼了一下。脑袋里装的稀奇古怪的想法没有什么人值得我倾诉，家人亦是如此，所以还是写到博客里痛快。以前手写日记的感觉很难再找到了，敲击键盘比拿出纸笔似乎更加容易，尽管如此我还是不知道下一次日记会写在什么时候。一切随缘吧！</p>
<p>[^1]: 《<a href="https://blog.imalan.cn/archives/247/">VOID：现在可以公开的情报 - 无文字|三无计划</a>》
[^2]: <a href="https://beyondstars.xyz/">@探索子</a> <a href="https://www.mina.moe/">@MiNa!</a> <a href="https://blog.ichr.me/">@ChrAlpha 的幻想乡</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mark 并调试 HEU 自动打卡代码]]></title>
        <id>https://blog.monsterx.cn/code/heu-auto-checkin-covid19/</id>
        <link href="https://blog.monsterx.cn/code/heu-auto-checkin-covid19/"/>
        <updated>2020-04-05T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>最近这几天又不知道干点啥，天天上课累死了，前面的还没掌握就又要接新的知识，真是太难了。心血来潮想好好学一下 JavaScript 什么的前端基础，找资料逛博客的时候碰巧发现了一个学长的博客，看到《<a href="https://zjw1.top/2020/03/10/auto_checkin_during_covid19_and_cas_sso_learning/">疫情期间自动健康打卡暨 CAS 单点登录认证实践 - SiteForZJW</a>》这篇文章，常年起不来床的我赶紧点开了，啊啊啊我为什么没有早点发现这种好东西啊，生气。</p>
<p>第一次看的时候了解到这个 Python 代码要自己先手动执行一边获取表单数据。Emmm，那是啥，好像不太了解呢，先 Mark 了！</p>
<h2 id="python-和依赖">Python 和依赖</h2>
<p>什么？你说这个年头还有人电脑上没装 Python？なんと！</p>
<p>Windows 系统直接上 Python 官网下载安装包，注意将 Python 安装目录添加到 PATH 环境变量，一并安装 pip。如果运行时显示缺少模块就 pip 安装一下。</p>
<pre><code class="language-bash">python -m pip install --upgrade pip
pip install requests lxml
</code></pre>
<h2 id="获取-form-data">获取 form Data</h2>
<p>今天早上起来的出奇的早（7 点半我就醒了），一想到学校的打卡十点前就要完成，我突然想到了那个自动打卡、表单数据的事情。于是我点开了浏览器开始尝试。</p>
<p>打开 <a href="http://one.hrbeu.edu.cn/infoplus/form/JKXXSB/start">网上办事中心 - 平安行动</a> ，虽然不知道是啥，但 F12 肯定会告诉我的。选择 Network 栏，网页从打开这个菜单后加载的所有请求都会在这里显示，先刷新一遍网页，找了一遍好像什么也没有（一开始我以为表单数据是缓存下来的什么东西），Emmm，提交一遍试试，点完确认提交之后 Network 最下面显示了一个新的名叫 <code>doAction</code> 资源，那一定就是你了！<strong>注意此时不要点确定，点确定之后该资源会被刷新掉。</strong></p>
<p>好的，<code>Form Data</code> Get√ 。选择 <code>view parsed</code> <code>view decoded</code> 就能看到这个表单的所有数据，也就是之前 Python 自动打卡需要自定义的。完整存好 <code>formData</code> <code>boundFields</code> 的内容。</p>
<p><img src="https://blog.monsterx.cn/code/heu-auto-checkin-covid19/images/post/heu-checkin1.png" alt="Network"><img src="https://blog.monsterx.cn/code/heu-auto-checkin-covid19/images/post/heu-checkin2.png" alt="doAction - Form Data"></p>
<h2 id="调试">调试</h2>
<p>表单数据有了，开始调试 Python 。</p>
<h3 id="邮件提醒">邮件提醒</h3>
<p>源代码最后的发送邮件部分需要自行引用发送邮件的 <code>.py</code> 文件，但是谷歌找到的好几个 <code>sendmail.py</code> 补上去之后都有奇怪的报错，比如 <code>if</code> 条件右括号报语法错误，我明明是直接复制的啊 QaQ ，看了好几遍也不应该有错啊（后来发觉可能是 Python 版本问题）。最终我索性直接搜 Python SMTP 的用法，找了一段代码补上去。</p>
<p>在 Linux 下试运行的时候发现打卡段没问题，但是后面邮件发送这段报错：</p>
<pre><code class="language-powershell">Traceback (most recent call last):
  File &quot;checkin.py&quot;, line 151, in &lt;module&gt;
    smtpObj.connect(mail_host, 25)    # 25 为 SMTP 端口号
  File &quot;/usr/lib64/python3.6/smtplib.py&quot;, line 336, in connect
    self.sock = self._get_socket(host, port, self.timeout)
  File &quot;/usr/lib64/python3.6/smtplib.py&quot;, line 307, in _get_socket
    self.source_address)
  File &quot;/usr/lib64/python3.6/socket.py&quot;, line 724, in create_connection
    raise err
  File &quot;/usr/lib64/python3.6/socket.py&quot;, line 713, in create_connection
    sock.connect(sa)
TimeoutError: [Errno 110] Connection timed out
</code></pre>
<p>搜索了一圈发现 Linux 下 SMTP 发信加密程度要求更高，所以得加密发信，将原来的发信替换为 SSL 加密发信：</p>
<pre><code class="language-python">smtpObj = smtplib.SMTP_SSL() 
smtpObj.connect(mail_host, 465)      # 一般加密发信 smtp 端口号为 465
</code></pre>
<p>在 3.7 版本以上的 Python 中需要此脚本时必须使用 <code>smtpObj = smtplib.SMTP_SSL(mail_host)</code> ，否则邮件发信会报错 ValueError 如下：</p>
<pre><code class="language-powershell">Traceback (most recent call last):
  File &quot;/home/Project/Python/HEUCheckin-2018041015.py&quot;, line 170, in &lt;module&gt;
    smtpObj.connect(mail_host, 465)       # 加密时 SMTP 端口号为 465
  File &quot;/usr/local/Python3.8.2/lib/python3.8/smtplib.py&quot;, line 339, in connect
    self.sock = self._get_socket(host, port, self.timeout)
  File &quot;/usr/local/Python3.8.2/lib/python3.8/smtplib.py&quot;, line 1042, in _get_socket
    new_socket = self.context.wrap_socket(new_socket,
  File &quot;/usr/local/Python3.8.2/lib/python3.8/ssl.py&quot;, line 500, in wrap_socket
    return self.sslsocket_class._create(
  File &quot;/usr/local/Python3.8.2/lib/python3.8/ssl.py&quot;, line 1031, in _create
    self._sslobj = self._context._wrap_socket(
ValueError: server_hostname cannot be an empty string or start with a leading dot.
</code></pre>
<h3 id="关闭代理">关闭代理</h3>
<p>本地调试的时候，由于我平时习惯开 Clash 代理挂着，没注意这个，结果就报错了，信息如下：</p>
<details><summary><strong>Python Traceback</strong></summary><br />


<pre><code class="language-powershell">Traceback (most recent call last):
  File &quot;D:\Python\Python38-64\lib\site-packages\urllib3\connectionpool.py&quot;, line 665, in urlopen
    httplib_response = self._make_request(
  File &quot;D:\Python\Python38-64\lib\site-packages\urllib3\connectionpool.py&quot;, line 421, in _make_request
    six.raise_from(e, None)
  File &quot;&lt;string&gt;&quot;, line 3, in raise_from
  File &quot;D:\Python\Python38-64\lib\site-packages\urllib3\connectionpool.py&quot;, line 416, in _make_request
    httplib_response = conn.getresponse()
  File &quot;D:\Python\Python38-64\lib\http\client.py&quot;, line 1322, in getresponse
    response.begin()
  File &quot;D:\Python\Python38-64\lib\http\client.py&quot;, line 303, in begin
    version, status, reason = self._read_status()
  File &quot;D:\Python\Python38-64\lib\http\client.py&quot;, line 272, in _read_status
    raise RemoteDisconnected(&quot;Remote end closed connection without&quot;
http.client.RemoteDisconnected: Remote end closed connection without response

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File &quot;D:\Python\Python38-64\lib\site-packages\requests\adapters.py&quot;, line 439, in send
    resp = conn.urlopen(
  File &quot;D:\Python\Python38-64\lib\site-packages\urllib3\connectionpool.py&quot;, line 719, in urlopen
    retries = retries.increment(
  File &quot;D:\Python\Python38-64\lib\site-packages\urllib3\util\retry.py&quot;, line 436, in increment
    raise MaxRetryError(_pool, url, error or ResponseError(cause))
urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host=&#39;127.0.0.1&#39;, port=7890): Max retries exceeded with url: http://cas.hrbeu.edu.cn/cas/login?service=http%3A%2F%2Fjkgc.hrbeu.edu.cn%2Finfoplus%2Flogin%3FretUrl%3Dhttp%253A%252F%252Fjkgc.hrbeu.edu.cn%252Finfoplus%252Fform%252FJSXNYQSBtest%252Fstart%253Fticket%253DST-3779417-6SDr7iRPSkJxSd3MFyNd-cas01.example.org (Caused by ProxyError(&#39;Cannot connect to proxy.&#39;, RemoteDisconnected(&#39;Remote end closed connection without response&#39;)))

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File &quot;d:/workshop/PythonProject/CheckIn/checkin.py&quot;, line 61, in &lt;module&gt;
    response302 = sesh.post(req.url, data=user_form, headers=headers)
  File &quot;D:\Python\Python38-64\lib\site-packages\requests\sessions.py&quot;, line 578, in post
    return self.request(&#39;POST&#39;, url, data=data, json=json, **kwargs)
  File &quot;D:\Python\Python38-64\lib\site-packages\requests\sessions.py&quot;, line 530, in request
    resp = self.send(prep, **send_kwargs)
  File &quot;D:\Python\Python38-64\lib\site-packages\requests\sessions.py&quot;, line 665, in send
    history = [resp for resp in gen] if allow_redirects else []
  File &quot;D:\Python\Python38-64\lib\site-packages\requests\sessions.py&quot;, line 665, in &lt;listcomp&gt;
    history = [resp for resp in gen] if allow_redirects else []
  File &quot;D:\Python\Python38-64\lib\site-packages\requests\sessions.py&quot;, line 237, in resolve_redirects
    resp = self.send(
  File &quot;D:\Python\Python38-64\lib\site-packages\requests\sessions.py&quot;, line 643, in send
    r = adapter.send(request, **kwargs)
  File &quot;D:\Python\Python38-64\lib\site-packages\requests\adapters.py&quot;, line 510, in send
    raise ProxyError(e, request=request)
requests.exceptions.ProxyError: HTTPConnectionPool(host=&#39;127.0.0.1&#39;, port=7890): Max retries exceeded with url: http://cas.hrbeu.edu.cn/cas/login?service=http%3A%2F%2Fjkgc.hrbeu.edu.cn%2Finfoplus%2Flogin%3FretUrl%3Dhttp%253A%252F%252Fjkgc.hrbeu.edu.cn%252Finfoplus%252Fform%252FJSXNYQSBtest%252Fstart%253Fticket%253DST-3779417-6SDr7iRPSkJxSd3MFyNd-cas01.example.org (Caused by ProxyError(&#39;Cannot connect to proxy.&#39;, RemoteDisconnected(&#39;Remote end closed connection without response&#39;)))
</code></pre>
</details><br />


<p>报错一大堆没怎么看懂，<code>ProxyError</code> 看来应该是代理问题，可能和主机的网络设置有关系，没有深究原因，所以解决方案就是 <strong>关掉代理</strong> ！</p>
<blockquote>
<p>尝试了在运行前用 <code>export</code> 或者 <code>set</code> 命令设置 <code>http_proxy</code> <code>https_proxy</code> 代理，也一样无法使用。</p>
</blockquote>
<h3 id="结果判定">结果判定</h3>
<p>调试时还发现个问题，原代码打卡出错的判定有缺陷，只报 Python 脚本出 Exception 时的错，而提交表单时可能成功提交，但是返回的不是打卡成功，而是打卡失败。那么如何判断打卡提交正常但是打卡失败呢，这里关注返回的数据 <code>response_end</code> ，用 requests 库转换成 text 后的 <code>response_end.text</code> 缩进一下长这个样子：</p>
<pre><code class="language-json"># 成功时
{
  &quot;errno&quot;:0,
  &quot;ecode&quot;:&quot;SUCCEED&quot;,
  &quot;entities&quot;:[{
    &quot;stepId&quot;:2,
    &quot;name&quot;:&quot;办结&quot;,
    &quot;code&quot;:&quot;autoStep1&quot;,&quot;status&quot;:0,&quot;type&quot;:&quot;Auto&quot;,&quot;flowStepId&quot;:0,&quot;executorSelection&quot;:0,&quot;timestamp&quot;:0,&quot;posts&quot;:[],&quot;users&quot;:[],&quot;parallel&quot;:false,&quot;hasInstantNotification&quot;:false,&quot;hasCarbonCopy&quot;:false,&quot;entryId&quot;:2797847,&quot;entryStatus&quot;:0,&quot;entryRelease&quot;:false
  }]
}

# 失败时
{
  &quot;errno&quot;:22001,
  &quot;ecode&quot;:&quot;EVENT_CANCELLED&quot;,
  &quot;error&quot;:&quot;发生异常\n\njava.lang.reflect.InvocationTargetException\n\tat sun.reflect.GeneratedMethodAccessor457.invoke(Unknown Source)\n\t...\n&quot;,
  &quot;entities&quot;:[]
}
</code></pre>
<p>可以看到返回的字段中 <code>errno</code> 为 <code>0</code> 代表成功提交，剩下的 <code>ecode</code> 显示 <code>str</code> 型的状态，<code>error</code> 只有出现错误时才有，包含了所有的错误信息，这个错误是在学校服务器上报的，不是本地脚本的问题。<code>entities</code> 包含成功提交后的一些数据。那么这就用 <code>errno</code> 来判定远程提交后返回是否成功。先使用 <code>json.loads()</code> 将其转换为 JSON 格式，注意在返回的数据中 <code>errno</code> 字段为 <code>int</code> 类型，<code>entities</code> 字段为 <code>list</code> 类型，发信的 <code>msg</code> 要用 <code>str()</code> 转换这两个数据。</p>
<p>实现代码如下：</p>
<pre><code class="language-python">try:
    # ......

    response_end = sesh.post(submit_url, data=submit_form, headers=headers)
    resJson = json.loads(response_end.text)

    print(&#39;Form url: &#39;, form_response.url)
    # print(&#39;Form status: &#39;, response_end.text)
    print(&#39;Form Status: &#39;, resJson[&#39;ecode&#39;])
    print(&#39;Form stJson: &#39;, resJson)
    # 获取表单返回 Json 数据所有 key 用这个
    # print(&#39;Form stJsonkey: &#39;, resJson.keys())

    # 加入远程提交返回结果判断
    if (resJson[&#39;errno&#39;] == 0):
        print(&#39;Form Succeed: &#39;, resJson[&#39;ecode&#39;])
        title = f&#39;打卡成功 &lt;{submit_form[&quot;stepId&quot;]}&gt;&#39;
        msg = &#39;\t表单地址: &#39; + form_response.url + &#39;\n\n\t表单状态: \n\t\terrno：&#39; + str(resJson[&#39;errno&#39;]) + &#39;\n\t\tecode：&#39; + str(resJson[&#39;ecode&#39;]) + &#39;\n\t\tentities：&#39; + str(resJson[&#39;entities&#39;]) + &#39;\n\n\n\t完整返回：&#39; + response_end.text
    else:
        print(&#39;Form Error: &#39;, resJson[&#39;ecode&#39;])
        title = f&#39;打卡失败！校网出错&#39;
        msg = &#39;\t表单地址: &#39; + form_response.url + &#39;\n\n\t错误信息: \n\t\terrno：&#39; + str(resJson[&#39;errno&#39;]) + &#39;\n\t\tecode：&#39; + str(resJson[&#39;ecode&#39;]) + &#39;\n\t\tentities：&#39; + str(resJson[&#39;entities&#39;]) + &#39;\n\n\n\t完整返回：&#39; + response_end.text
except:
    print(&#39;\n:.:.:.:.: Except return :.:.:.:.:&#39;)
    err = traceback.format_exc()
    print(&#39;Python Error: \n&#39;, err)
    title = &#39;打卡失败！脚本出错&#39;
    msg = &#39;\t脚本报错: \n\n\t&#39; + err
</code></pre>
<p>好啦，现在就差不多完美了，唯一美中不足的就是没有加入 <code>retry</code> 的功能，还不了解这个怎么实现，有空可以试试。</p>
<h2 id="完工">完工</h2>
<details><summary><strong>修补完整的 auto-checkin.py</strong></summary><br />


<pre><code class="language-python">#!/usr/bin/env python3
# -*- coding: UTF-8 -*-

&quot;&quot;&quot;
平安行动自动打卡

Created on 2020-04-13 20:20
@author: ZhangJiawei &amp; Monst.x
&quot;&quot;&quot;

import requests
import lxml.html
import re
import json
import random
import time
import smtplib
import traceback

headers = {
    &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;,
    &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br&quot;,
    &quot;Accept-Language&quot;: &quot;zh-CN&quot;,
    &quot;Cache-Control&quot;: &quot;max-age=0&quot;,
    &quot;Connection&quot;: &quot;keep-alive&quot;,
    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,
    &quot;Cookie&quot;: &quot;MESSAGE_TICKET=%7B%22times%22%3A0%7D; &quot;,
    &quot;Host&quot;: &quot;cas.hrbeu.edu.cn&quot;,
    &quot;Referer&quot;: &quot;https://cas.hrbeu.edu.cn/cas/login?service=http%3A%2F%2Fjkgc.hrbeu.edu.cn%2Finfoplus%2Flogin%3FretUrl%3Dhttp%253A%252F%252Fjkgc.hrbeu.edu.cn%252Finfoplus%252Fform%252FJSXNYQSBtest%252Fstart&quot;,
    &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;,
    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36 Edge/18.18362&quot;
}

data = {
    &quot;username&quot;:&quot;studentNumber&quot;,                # 学号
    &quot;password&quot;:&quot;password&quot;                      # 教务处密码
}
def findStr(source, target):
    return source.find(target) != -1
title = &quot;&quot;
msg = &quot;&quot;

try:
    #get
    url_login = &#39;https://cas.hrbeu.edu.cn/cas/login?service=http%3A%2F%2Fjkgc.hrbeu.edu.cn%2Finfoplus%2Fform%2FJSXNYQSBtest%2Fstart&#39;
    print(&quot;Begin to login ...&quot;)
    sesh = requests.session()
    req = sesh.get(url_login)
    html_content = req.text

    #post
    login_html = lxml.html.fromstring(html_content)
    hidden_inputs=login_html.xpath(r&#39;//div[@id=&quot;main&quot;]//input[@type=&quot;hidden&quot;]&#39;)
    user_form = {x.attrib[&quot;name&quot;] : x.attrib[&quot;value&quot;] for x in hidden_inputs}

    user_form[&quot;username&quot;]=data[&#39;username&#39;]
    user_form[&quot;password&quot;]=data[&#39;password&#39;]
    user_form[&quot;captcha&quot;]=&#39;&#39;
    user_form[&quot;submit&quot;]=&#39;登 录&#39;
    headers[&#39;Cookie&#39;] = headers[&#39;Cookie&#39;] + req.headers[&#39;Set-cookie&#39;]

    req.url = f&#39;https://cas.hrbeu.edu.cn/cas/login;jsessionid={req.cookies.get(&quot;JSESSIONID&quot;)}?service=http%3A%2F%2Fjkgc.hrbeu.edu.cn%2Finfoplus%2Fform%2FJSXNYQSBtest%2Fstart&#39;
    response302 = sesh.post(req.url, data=user_form, headers=headers)
    casRes = response302.history[0]
    print(&quot;CAS response header&quot;, findStr(casRes.headers[&#39;Set-Cookie&#39;],&#39;CASTGC&#39;))

    #get
    jkgc_response = sesh.get(response302.url)

    #post
    headers[&#39;Accept&#39;] = &#39;*/*&#39;
    headers[&#39;Cookie&#39;] = jkgc_response.request.headers[&#39;Cookie&#39;]
    headers[&#39;Host&#39;] = &#39;jkgc.hrbeu.edu.cn&#39;
    headers[&#39;Referer&#39;] = jkgc_response.url
    jkgc_html = lxml.html.fromstring(jkgc_response.text)
    csrfToken = jkgc_html.xpath(r&#39;//meta[@itemscope=&quot;csrfToken&quot;]&#39;)
    csrfToken = csrfToken.pop().attrib[&quot;content&quot;]
    jkgc_form = {
        &#39;idc&#39;: &#39;JSXNYQSBtest&#39;,
        &#39;release&#39;: &#39;&#39;,
        &#39;csrfToken&#39;: csrfToken,
        &#39;formData&#39;: {
            &#39;_VAR_URL&#39;: jkgc_response.url,
            &#39;_VAR_URL_Attr&#39;: {
                &#39;ticket&#39;: re.match(r&#39;.*ticket=(.*)&#39;, jkgc_response.url).group(1)
            }
        }
    }
    jkgc_form[&#39;formData&#39;] = json.dumps(jkgc_form[&#39;formData&#39;])
    jkgc_url = &#39;http://jkgc.hrbeu.edu.cn/infoplus/interface/start&#39;
    response3 = sesh.post(jkgc_url, data=jkgc_form, headers=headers)

    #get
    form_url = json.loads(response3.text)[&#39;entities&#39;][0]
    form_response = sesh.get(form_url)

    #post
    headers[&#39;Accept&#39;] = &#39;application/json, text/javascript, */*; q=0.01&#39;
    headers[&#39;Referer&#39;] = form_url
    headers[&#39;X-Requested-With&#39;] = &#39;XMLHttpRequest&#39;
    submit_url = &#39;http://jkgc.hrbeu.edu.cn/infoplus/interface/doAction&#39;

    submit_html = lxml.html.fromstring(form_response.text)
    csrfToken2 = submit_html.xpath(r&#39;//meta[@itemscope=&quot;csrfToken&quot;]&#39;)
    csrfToken2 = csrfToken2.pop().attrib[&quot;content&quot;]

    submit_form = {
        &#39;actionId&#39;: &#39;1&#39;,
        # boundFields 修改位置
        &#39;boundFields&#39;: &#39;fieldCXXXdqszdjtx,fieldCXXXjtgjbc,...&#39;,
        &#39;csrfToken&#39;: csrfToken2,
        # formData 修改位置
        &#39;formData&#39;: r&#39;{&quot;_VAR_EXECUTE_INDEP_ORGANIZE_Name&quot;:&quot;学院&quot;,&quot;_VAR_ACTION_INDEP_ORGANIZES_Codes&quot;:&quot;xxxxx&quot;,...}&#39;,
        &#39;lang&#39;: &#39;zh&#39;,
        &#39;nextUsers&#39;: &#39;{}&#39;,
        &#39;rand&#39;: str(random.random() * 999),
        &#39;remark&#39;: &#39;&#39;,
        &#39;stepId&#39;: re.match(r&#39;.*form/(\d*?)/&#39;,form_response.url).group(1),
        &#39;timestamp&#39;: str(int(time.time()+0.5))
    }
    response_end = sesh.post(submit_url, data=submit_form, headers=headers)
    resJson = json.loads(response_end.text)

    ## 表单填写完成，返回结果
    print(&#39;Form url: &#39;, form_response.url)
    # print(&#39;Form status: &#39;, response_end.text)
    print(&#39;Form Status: &#39;, resJson[&#39;ecode&#39;])
    print(&#39;Form stJson: &#39;, resJson)
    # 获取表单返回 Json 数据所有 key 用这个
    # print(&#39;Form stJsonkey: &#39;, resJson.keys())

    if (resJson[&#39;errno&#39;] == 0):
        print(&#39;Form Succeed: &#39;, resJson[&#39;ecode&#39;])
        title = f&#39;打卡成功 &lt;{submit_form[&quot;stepId&quot;]}&gt;&#39;
        msg = &#39;\t表单地址: &#39; + form_response.url + &#39;\n\n\t表单状态: \n\t\terrno：&#39; + str(resJson[&#39;errno&#39;]) + &#39;\n\t\tecode：&#39; + str(resJson[&#39;ecode&#39;]) + &#39;\n\t\tentities：&#39; + str(resJson[&#39;entities&#39;]) + &#39;\n\n\n\t完整返回：&#39; + response_end.text
    else:
        print(&#39;Form Error: &#39;, resJson[&#39;ecode&#39;])
        title = f&#39;打卡失败！校网出错&#39;
        msg = &#39;\t表单地址: &#39; + form_response.url + &#39;\n\n\t错误信息: \n\t\terrno：&#39; + str(resJson[&#39;errno&#39;]) + &#39;\n\t\tecode：&#39; + str(resJson[&#39;ecode&#39;]) + &#39;\n\t\tentities：&#39; + str(resJson[&#39;entities&#39;]) + &#39;\n\n\n\t完整返回：&#39; + response_end.text
except:
    print(&#39;\n:.:.:.:.: Except return :.:.:.:.:&#39;)
    err = traceback.format_exc()
    print(&#39;Python Error: \n&#39;, err)
    title = &#39;打卡失败！脚本出错&#39;
    msg = &#39;\t脚本报错: \n\n\t&#39; + err
finally:
    print(&#39;\n:.:.:.:.: Finally :.:.:.:.:&#39;)
    ## 发送邮件
    # import sendmail     ## 这个是普通.py文件，不是Python库
    # sendmail.sendmail(title, msg)

    from email.mime.text import MIMEText
    from email.header import Header
 
    # 第三方 SMTP 服务
    mail_host=&quot;smtp.exmail.qq.com&quot;                 # 设置 smtp 服务器
    mail_user=&quot;example@example.com&quot;                # smtp 发信邮箱用户名
    mail_pass=&quot;emailpassword&quot;                      # smtp 发信邮箱密码
    sender = &#39;1@example.com&#39;                       # 发信邮箱显示
    receivers = [&#39;2@example.com&#39;]                  # 修改为收件人邮箱，多邮箱以数组形式写
    message = MIMEText(msg, &#39;plain&#39;, &#39;utf-8&#39;)
    message[&#39;From&#39;] = Header(&quot;1@example.com&quot;, &#39;utf-8&#39;)        # 发件人邮箱
    message[&#39;To&#39;] =  Header(&quot;2@example.com&quot;, &#39;utf-8&#39;)         # 收件人邮箱
    subject = title
    message[&#39;Subject&#39;] = Header(subject, &#39;utf-8&#39;)
    try:
        # smtpObj = smtplib.SMTP()              # 使用一般发信
        # smtpObj.connect(mail_host, 25)        # 不加密时 SMTP 端口号为 25
        # smtpObj = smtplib.SMTP_SSL()          # Python 3.7 以下版本 SSL 加密发信
        smtpObj = smtplib.SMTP_SSL(mail_host)   # Python 3.7 及以上版本 SSL 加密发信
        smtpObj.connect(mail_host, 465)         # 加密时 SMTP 端口号为 465
        smtpObj.login(mail_user,mail_pass)
        smtpObj.sendmail(sender, receivers, message.as_string())
        print (&quot;Success: The email was sent successfully&quot;)
    except smtplib.SMTPException:
        print (&quot;Error: Can not send mail&quot;)
</code></pre>
</details><br />


<p>合理地偷个懒，需要修改的地方都在代码注释里了。</p>
<h2 id="定时任务">定时任务</h2>
<p>要想让代码实现自动打卡，还需要另外设置定时任务，Linux 可以用 <strong>crontab</strong>，Windows 可以用 <strong>任务计划程序</strong>。</p>
<pre><code class="language-bash"># Linux 下添加 crontab 定时命令，每天 8:00 执行打卡并输出日志到 .log 文件
# 建议先运行测试是否可行
# python3 auto-checkin.py

crontab -e
0 8 * * * root /path/to/python3 /path/to/auto-checkin.py &gt; /path/to/checkin.log
# :wq 保存并退出
</code></pre>
<p>Windows 下按 <code>win</code> 搜索“任务计划程序”调出菜单，然后在右栏选择创建基础任务。跟着创建基本任务向导的指示一步一步来就好了，「触发器 -&gt; 每日」设置时间推荐避开 6:00 腐败街预约打卡的高峰，8:00 就不错。「操作 -&gt; 启动程序」的程序或脚本项按下面格式填写。</p>
<p><img src="https://blog.monsterx.cn/code/heu-auto-checkin-covid19/images/post/heu-autotask.png" alt="Windows 定时任务设置"></p>
<p>Okay，睡个回笼觉庆祝一下 🥳..</p>
<blockquote>
<p>查看《<a href="https://blog.monsterx.cn/tech/modified-github-actions-4-heu-checkin/">照葫芦画瓢 · 编写 Actions 打卡工作流</a>》了解 GitHub Actions 版本。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[年度 · 2019]]></title>
        <id>https://blog.monsterx.cn/life/2019-annual-summary/</id>
        <link href="https://blog.monsterx.cn/life/2019-annual-summary/"/>
        <updated>2020-03-10T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>闲来无事逛逛别人的博客，看到了 DIYgod 大佬的年终总结。我想起来 2019 我好像还没有写总结呢！元旦跨年时我就在网站数据统计上草率地截了一张图，塞在自言页面。那时我感觉自己的 2019 是极其失败的一年，我渐渐活成了不想自己成为的那种人：庸碌无为、不思进取，这一点也不值得我写出来。现在又写下来并不是突然觉得 2019 也还说得过去了，而是想想也许活得的确失败，但还是不妨记录下来存档。</p>
<p>像 2018 总结一样，先上一首歌。</p>
<pre><code>[Meting-Music server=&quot;tencent&quot; id=&quot;002rKsUf3HUKfx&quot; type=&quot;song&quot;/]
</code></pre>
<p>翻了翻自己的歌单，这首 2019 听到的歌（《记昨日书》）正好风格一致。本来是从群聊里一位朋友在 K 歌唱的歌里听到的，觉得歌词挺好的。尤其是安静独处的时候，这首歌让我想起了以前的琐事…</p>
<h2 id="寒假">寒假</h2>
<p>2019 年元旦，我应该还沉浸在自己写的 2018 总结里，我把那篇文章广播到了 QQ 空间，点赞的评论的也许都有所感触吧，毕竟大家都是刚从高中进入大学，很多事情应该和我的总结里有共鸣吧，我猜。之后是大一的第一次期末，我慵懒的带上笔和学生证就上考场了，很随意，抱着反正大学才刚刚开始的态度（挂科有什么可怕的，我当时这样想，只要我开始学不就不会挂科么）。考试结束后室友都回家了，只有我最后一个走，帮室友盖了床铺，晚上的时候寝室没有人，我就站在寝室的空地上伸懒腰，到上铺体验上铺的视角：脑袋空空，盯着天花板，我感觉自己就好像还是第一次躺在这个寝室似的，莫名的新鲜感。我宅在寝室享受哈尔滨的暖气和爸妈给的生活费，刷着 QQ 动态看别人趁回家前去了冰雪大世界、中央大街，我却一点都不羡慕，甚至想说一句：这大冬天外面这么冷怎么可能出去玩呢？</p>
<p>从寝室离开的那天，我提前收拾了一行李箱的东西，衣服书籍，准备回家大干一场。打了个车从寝室楼下到火车站，第一次一个人坐火车，有一种他乡游子的凄凉感。坐上火车我爸妈一路关切，而我带着耳机在火车上看群聊、听歌、看电影，丝毫不觉得想家，还在心里计划着大三大四忙的时候暑假干脆不回家了。回到家那几天我和高中几个同学在群聊里策划着什么时候聚会，我很好奇大家经历了半个大一都变没变呢？是不是大家都开始变美变帅学化妆辣？我是不是大家伙里的 Low 比呢？实际到聚会的时候我好像有很多话说，但又变得像高中那样拘谨起来，可能是因为有两个女生在场吧。我们的第一次聚会是小团体的，班级上并没有要聚会的意思，而且班长因为复读的关系也不好联系大家。这次见的都是铁哥们，算是一直以来唠嗑打游戏的骨灰级基友。另外两个女生也是在群里聊天的同学，感兴趣就一起来了，大家围在自助火锅面前，吃了一顿简简单单的午饭！第一次同学聚会的感觉，不可描述。我和他们面对面的聊起了琐碎的事情，各自的学校、寝室关系、课表安排等等，虽然也没少相互磕碜，但跟群里口嗨还是很不一样的。</p>
<p>寒假在家，我带回来了 Arduino UNO 的开发板，继续做学校的科创项目。我以为这会是我开启大学科创的敲门砖，现在看来却好像成了唯一。我在家没事不想看微积分什么的时候就连起杜邦线，对着发光的板子琢磨科创项目的事。当然也跟组里的二把手天天聊天聊出了巨轮，也就是友链里的隔壁床博客（真的是寝室隔壁床哈哈，他的是 CSDN 博客没有什么特别的站点名称，我就给他起了个「隔壁床博客」的标题）。除夕，又是没有亲戚回家一起过年的年，我感觉十分没有年味，春晚也没什么吸引我的地方。于是父母在看春晚的时候我就一个人溜进了自己的房间继续捣鼓 Arduino ，大年初一我的 Arduino 风扇已经安排上了红外遥控，虽然还时有失灵的状况，但是程序方面已经思路清晰了。我和隔壁床在 QQ 上带炫耀的意味发了风扇的运行视频，还和一些朋友拜了个网络年。这种 QQ 消息拜年我觉得越来越无趣了，以前还会挨个发祝福，赶在 0:00 讨彩头，现在我甚至连最好的朋友都懒得发了。你在意的人自有 Ta 在意的人，对 Ta 而言你的祝福只不过会加重 Ta 回复在意之人消息的负担。当然我这里并不是因为什么感情关系才这样说，而是我经历了几年的拜年祝福觉得事实可能就是这样无情。</p>
<h2 id="春季学期">春季学期</h2>
<p>年过完正月十五我就在家呆不住了，一方面是手机校园套餐在家省外流量不够用了，二是学校的补考工作正等着我支持呢。正月十七，我带上行李离家返校，剩下父母在家守望。想起来我 tnd 还真是个带孝子！回学校的火车是跟室友一起坐的，我在北京中转了，买了学生票还是贵的很，每次花这些车票钱我都心疼。和室友一起回哈的时候车站到学校的地铁已经停运了，我们只好在附近的宾馆先住下了。坐了一天的火车，我和室友订好房间就出去吃了顿晚饭，麻辣烫就青岛啤酒，十分过瘾。</p>
<p>回学校已经是大一下的我开始了新学期的 flag ，坚持了没有几天吧就不行了，上课太容易打瞌睡了。学习的态度也十分差，这导致我的微积分更加危险了。但是下学期有一门编程语言基础，讲授 C 语言，这对于在家看了 Arduino 的我来说简直小菜一碟，我表面低调的听课写代码，实际内心高兴的跳起来：这就是我想学的！但是后来情况有变，指针结构体之后我就不怎么明白了，我自己虽然也看了很多遍但是都卡住了，我不懂这些复杂的东西怎么用，教材讲的也不是十分详细。我开始懈怠，虽然作业还是一样的做了，但是我自己也感觉质量不行，代码写的稍复杂一点自己就蒙了。最后课程结课是交一项大作业，也就是我发博文的日历程序，从第一次发布的日历程序博文质量一叶知秋。这个项目是分工合作的，虽然代码基本都是我写的，但我还是给另外两个组员各自分了行数，并给他们讲思路，最后整理项目报告。我以为项目完成得不错，大家也都可以良好起步吧，结果最后只有我是优秀，而另外两个组员都是中等。我觉得自己太失败了，而且太自大了，以为自己能 Carry ，最后却啥也不是。</p>
<p>大一下开了工图课，开始还蛮有兴趣的，后来发现老师每次都是不停的提问然后放 ppt 过，我很不喜欢，渐渐的只能自己看书来学了。画工图的时候也总是有所参照的画，实际就很没效果，因为不会自己想结构想知识点了。不过还好，之后通过了考试。选修课我选了一门书法一门科技创新训练。书法是因为很想念墨香味，毕竟安徽也是文化大省（让我吹一下）。科技创新训练就不一样了，我选课的时候看到这门课一整天的课表很好奇到底能学到什么，于是就选了。实际上老师讲的也还行，不过有点跟不上，大家上课都把电脑带着去教室，我就刷刷博客看看好玩的，有些细节不咋听。最后结课让做重力势能小车，挺新奇的玩意。而且有意思的是我开课组队的时候还被分到了两个女生里，一个还是同县老乡。要交结课报告那天晚上我通宵一宿边刷哔哩哔哩和抖音边画工图写报告，最后虽然小车没有成功的跑起来，但是还是靠报告拿了个优秀。哦顺带记一下我这一年通宵的时候越来越多了，尤其是英语每月考核的时候通宵看 U 校园背材料。很多时间被我花在了看剧上，比如《新倚天屠龙记》《权力的游戏第八季》，还有在哔哩哔哩看徐大 sao 、美食作家王刚什么的。</p>
<p>大一下还有一件事就是科创引导型立项结题，也就是我寒假在家做的 Arduino 调速风扇，经过几次中期检查，我发现自己的东西做的实在太简陋了，在学校的时间我又尝试着给风扇添加了一个 SG90 舵机做摇头的功能。本来风扇红外遥控的小问题加上舵机之后变得十分难搞，两个问题掺杂在一起我十分头疼，这个行那个崩、改那个这个崩。最终我将错误调到了一个较可控的范围内，这些事情我都作为博客的技术文章发布了，还有关于最后答辩的事也在博文中说过了。整个流程走完我的体验就是麻烦，我宁愿自己做个什么也不想再参加比赛了，各种文稿、检查真的让人头疼，还有就是队友和自己频道不在一起，代码没法理解，就算队友写了报告，我也会想要自己再查一遍。应该是我的合作能力出问题了吧。</p>
<h2 id="暑假">暑假</h2>
<p>暑假没有什么好说的，放假后室友们都留了一两天才走，大概是也想体会放假待寝室的感觉吧。暑假在家我没干什么正事，倒是准备做菜给爸妈吃。毕竟在哔哩哔哩看了无数的美食视频我觉得我也行了，无非就是葱姜蒜老抽生抽蚝油十三香什么的嘛！才回家的那几天我呆在家很郁闷，因为爸妈没有暑假，他们都依旧在县城工作，而我和爷爷在农村，我想给他们做菜的愿望落空了。妈妈隔三岔五地从县城回来给我做菜吃，我心里却很生气，明明是应该让她尝我做的菜的，可现在却是这个样子。我在家做菜的日子很枯燥，早晨都在床上躺到屋子里热的睡不下去了才起床，到下午一二点爷爷弯着腰慢吞吞的在我窗边问我：个出来做菜了啊？搞得我很烦，好像我就从现在要开始养家糊口了一样。我从一开始的兴奋到后来得不耐烦，做菜渐渐成为了负担。我不再像最初一样把每天做的菜拍下来留念，生活的仪式感被时间磨灭殆尽。才刚成年就越发感觉到生活可真难啊。</p>
<p>终于有一天，我没有耐住爷爷的催促，我生气了。为什么是我天天做菜？我姐姐也在家为什么她天天吃着我做的菜却理所当然似的？爷爷为什么不去催催她天天催我？我心里的不平衡让我粗暴地收拾好了回学校的行李，车票也一并订好了。我打电话给在县城工作的妈妈说我过两天就走，我那天中午没吃饭，晚上妈妈回家来看我，第二天早上我就和妈妈一起到县城了。我在妈妈工作的地方呆了几天，但是那里条件太差了，天热得要死却只有一个风扇吹，需要的时候还要在两个房间搬来搬去。我切身体会妈妈的工作环境，我没有跟他们撒气，只是依旧觉得非走不可。爸爸一整个暑假见到我的次数还没有我在这里呆的两天见得多，他一直都走不开。临走那天我爸妈帮我打了辆去市里的出租，上车前妈妈还哭着跟我说真的不再多留几天一定要走嘛？我很难受，咬咬牙走了。</p>
<h2 id="秋季学期">秋季学期</h2>
<p>回到学校，从 QQ 得知班级开始组织聚餐了，而我已经早早回到学校了，错过了这次班级聚会。不过还好，在 7 月我依旧和我的基友们聚会了一次，在一家烧烤店里吃了一顿，除了原班人马还有几个新加入我们的班长副班长等。提前回学校的日子里我呆在一个人的寝室，每天除了不用再亲手做菜之外没有什么好处，偶尔也会想想在家工作的爸妈，计划着国庆节不如回趟家作为补偿？</p>
<p>开学后我的日子有了一点变化。我开始早起吃早饭，认真听课预习；我开始坚持晚上跑圈散步，但是几个星期之后我又不行了。起初天气合适，我晚上出去跑步的时候隔三岔五给爸妈打电话，但是后来天气逐渐冷起来，我也懒了起来，给爸妈的电话的习惯也断了。在学校的日子除了上课下课我就在寝室呆着，在哔哩哔哩疯狂的补番追剧，在 Steam 疯狂的打奥德赛。我的补番战果基本上都列在 <a href="https://blog.monsterx.cn/watch">追番</a> 页了，我从只看《斗罗大陆》《武庚纪》的人变成了真正的猛男！追剧的成果也颇丰，最近的《从前有座灵剑山》和《庆余年》几乎就是我的快乐源泉。和室友也经常出去看电影，中间的时间我就在手机补各种电影。寝室的聚餐不怎么多了，倒是我和隔壁床经常没事就出去造一顿。小日子过得真舒服。</p>
<p>说到这就不得不说国庆了，本来计划着回家一趟，后来看了眼车票价格突然就决定了去旅游。东北三省只有长春有两个同学，我就决定去长春玩几天，顺便见见同学。国庆第一天我带了一个书包、几件衣服、充电宝、耳机就坐上了去长春的高铁。第一次正儿八经的旅游让我激动不已，拍照游玩不亦乐乎。正好第一天是国庆 70 周年，长春的公园里还不间断地播放着《我和我的祖国》。我在长春呆了三天，天天在宾馆住的都不想回学校了，要是生活就是这样到处走走停停那该多舒服啊！在长春的第二天晚上接到了爸爸的电话，我糊弄了几句就挂掉了，不知道他们要是知道了我自己一个人跑出去玩不回家会是什么心情。回到学校的时候我的一个室友刚好收拾了行李准备出去旅行。国庆节假结束前我把长春旅行的第一天写成了博文《<a href="#">独行 · 长春 [Day1]</a>》，后来由于懒得给相片压缩，长春旅行第二天第三天的日志都拖到了十一二月才更新出来（哦，第三天的我到现在都还没写出来）。</p>
<p>年末看 Steam 的统计我在奥德赛上花了 170+ 小时。这可以算是我入坑端游的第一部游戏，我陆续集齐了两个 DLC 并打完了，人物等级 71 级基本已经没有主线任务做了，有的时候看到周报说我一周在这个游戏上花了四五十小时的时候我几乎都惊呆了，7 天有两天相当于不眠不休地在奥德赛世界旅游。趁 Steam 促销我也买了绝地求生等一些游戏，但是玩的却很少很少，打了两局暴毙之后我就没怎么开过这个游戏了，还是看看别人玩就够了。我的一个室友天天和他朋友连麦打游戏，也不知道他是怎么做到一点不腻的。学期中间我有一段时间突然想玩英雄联盟，一直都没玩过这个游戏，看室友经常打的心态爆炸，我也好奇这个游戏到底怎么样。于是我就下载了 WeGame 安装 LOL ，不过和隔壁寝室友打了一局人机、打了一盘自走棋之后我就不想玩了，后来倒是那个隔壁寝室友时不时用我的电脑打游戏。后来有一次打折我在室友的安利下入手了 PVZ，算是入正了。那几天大家就围在我的电脑前看我大战僵尸的下饭操作，大家互相阴阳怪气，其乐融融。学期快结束的时候我入手了 Farm Together ，在社交功能里交了两个一起玩这个游戏的 Steam 好友，我才发现这个游戏真正好玩的点并不是独自种菜收菜，而是在好友的农场边聊天边装饰房屋啊！</p>
<h2 id="总纟">总纟</h2>
<p>一个学期就这样过去了。花在学习上的时间只占了一两成吧，失败都是有原因的。博客的更新上半年总体乐观，下半年几乎没有什么作为。这和我的追剧追番肝游戏有密不可分的联系，虽然归档页全部字数已经破 10 万字了，但是访问量并不多，都是我经常串访的友链朋友们来捧场。室友有的时候也来水评论（太水的我都无情地删掉了）。下面是 matomo 的统计数据，这是我从 2019.6.6 安装的统计程序，所以年度统计只有 6.6 之后的数据了。</p>
<p><img src="https://rmt.dogedoge.com/fetch/tingle/storage/2019analytics.png?w=985&fmt=webp" alt="2019 年访客情况"></p>
<p>这约莫就是我的 2019 了。2020 ：无 flag。</p>
<blockquote>
<p>文章头图源自 <a href="https://www.black-brick.com/december-2019">December 2019 - Black Brick</a> from Google Search.</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[年度 · 2018]]></title>
        <id>https://blog.monsterx.cn/life/2018-annual-summary/</id>
        <link href="https://blog.monsterx.cn/life/2018-annual-summary/"/>
        <updated>2019-01-20T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>突然想写写文章，想来已经有很久没有产出了。万念俱灰，无物可叙。试着听听这首歌读完这篇文章吧。</p>
<pre><code>[Meting-Music server=&quot;netease&quot; id=&quot;1313558186&quot; type=&quot;song&quot;/]
</code></pre>
<p>2018 年，是我难以忘却的一年。就像网传的段子所言，上半年我还在经历无尽的复习检测/模拟考试，下半年我却舒舒服服地躺在异乡某不知名大学的寝室里夜夜笙歌。回首这一年我仿佛在做梦一般，一切都如此难以置信，却又如此的真实。</p>
<blockquote>
<p>这人间袅袅炊烟
和风花雪月浪漫
痴情人多半贪恋
爱恨情仇都好看
又让你痛不欲生
又让你趁醉装疯</p>
</blockquote>
<p><strong>还记得 2018 年元旦</strong>，学校里结束了班级为单位的元旦晚会，第一次在新建成的礼堂举行全级的元旦晚会，连续三天下午举行了高一高二高三的晚会。大家在讨论哪个班哪个班的妹子如此光鲜靓丽，哪个班哪个班的帅哥才华横溢…而我却想起了数学老师曾经的诺言：高三的元旦晚会给大家唱歌，陪大家一起玩…… 现在，我再也没有机会看到它被实现的那一刻了。寒假，似乎是最后一个可以甩开别人的机会了，每个人或许都在拼了命地补缺补漏，而我已经不记得当时的我是看了多少书做了多少题还是玩了多少王者了…… 那时的我好像每一天都在前行与踌躇之间纠结，做题时都会幻想这一天我会在哪个地方痛快的玩/学，想着想着就心塞了——自己曾经玩手机落下的课程和打瞌睡错过的一轮复习似乎都是无法弥补的了，对自己的未来感到一片迷茫。开学好像是正月初几，<del>做了一套学校自己出的题（后来似乎发现是衡水中学的题），语文考的很好，理综考的很一般</del>（已经记不清这是暑假结束的事还是寒假结束的事了）。「江淮十校」联考和合肥市三次模拟考试是我们学校高度重视的考试。我依稀记得我呢好像从上学期的班级 20 名左右上升到 10 名左右了，但每次考试都慌慌张张，心里没底。高三我的成绩相比高一时十分堪忧，千里之堤溃于蚁穴，三年攒下来的不足在高三击垮了我，而我身边我曾经不以为然的人都成了黑马。说实话我很佩服他们能稳扎稳打干三年。当然，上半年我最高兴的事肯定就要数我终于成为上过校榜（高三是前 120 名）的人了，不过我并没有特意去看，因为那次班级最好的是年级第八还是十几二十名，对他来说上校榜是家常便饭。我很羞愧。三次模拟之后，大家都对自己的成绩有所把握了，我对我自己的估计是 580 上下，而三年前我的估计是 630 …… 网上的图都说高考前的学子上知天文下知地理无所不闻无所不知，而我却一如既往的普通。</p>
<p><strong>高考前夕</strong>，老师和家长都尽量营造一种平淡的氛围，不谈成绩，谈高考之后去哪里玩日后在哪里发展。我很深刻地记得高考前最后几天，最后几堂课：语文老师，那个快退休的老头子，给了全班男神女神最后的寄语；数学老师，我三年的上司，在自己班上一脸严肃在我们班却笑料不断的人，好像在最后一堂课聊了考试须知吧；英语老师，指引我三年的班主任，在最后一堂课上眼眶红红，还伴着他标志性的动作：鼻孔微张，让我难以忘却；物理老师，逗比小哥哥，最后一堂课还叫我们看看没讲完的《三维设计•二轮复习》后面的小册子；生物老师是个佛系少女，带着一副会变色的眼镜，在最后一堂课是不是其实也很难受呢？我不知道。倒是那个小姐姐化学老师流下的眼泪，让我也十分难受。最后一堂课说着说着她就哽咽着背过去面对黑板抽泣——终于还是抵挡不住分别的伤悲。那些告别，比三年前的更加撕心裂肺……甚至现在写起来，心中都充满悲伤。</p>
<p>父母呢，那段时间总是表面轻松地陪着我，现在再回想起来只有他们时不时因为琐事而吵闹的场景和对我复读机式的鼓舞…… 在我看来，他们识图付出一生辛劳来换我一生舒坦，而我所为，却又像是在自毁前程。</p>
<blockquote>
<p>终有天脱胎换骨
直到哭着笑才懂
欲问青天这人生有几何
怕这去日苦多
往事讨一杯相思喝</p>
</blockquote>
<p><strong>高考终于结束了</strong>，6 月 8 号我和基友们相约通宵，下了考场的我回到家放下书，拥抱着妈妈，没有说什么。晚上爸爸带着一家人出去吃饭，这似乎是三年来我印象中唯一一次家庭聚餐（不像家境较好的人家有一点喜事就出去吃饭，父母把所有的钱都节省下来了）。爸爸少有的提前回家了，一家人都欢欢喜喜的。晚上八九点我们才回到家。嗨了一会儿却感觉整个人都空虚了，我想念在一起拼搏的日子了，我想念那些一下课就凑在我身边的同学了，我害怕有一天我和他们见了面就像陌生人一样（我和我的小学同学已经基本没有联系了）。那天晚上我哭了。我写了一篇文章在空间，有点赞的，有评论的，其实大家都知道考完试再见面的机会就很少了。</p>
<p>暑假活的浑浑噩噩，相当无聊，并没有所谓的快感。每天都是 QQ、微博、知乎、腾讯视频、哔哩哔哩、王者荣耀、刺激战场，打开浏览器就是：mocurio.com、monsterx.cn、github.com、各大佬的博客。<strong>6 月在焦虑中度过</strong>，成绩出来那一天我很激动，感觉自己似乎是等了十年——上了六百分，有一点开心。而班上呢，那些从前就厉害的人六百二三扎堆，也有些我认为应该和我差不多的考失利了。心情很平淡，有些许不爽，也有些坦然。毕竟玩的太多，还算满意吧。<strong>7 月在纠结中度过</strong>，填志愿的时候，前两个狠狠地冲，中间两个就是我大概率命中的学校了，合肥工业大学和哈尔滨工程大学。又希望能满足父母的期望在合工大离家近一点，又希望能去曾经的「哈军工」见识冰城风采。即使最后录取通知书拿在手上了，我还是纠结自己为什么要来这么远的地方。<strong>8 月在烦躁中度过</strong>，在家玩的天昏地暗，笔再也没有动过，书再也没有翻过。原来计划好的《三体 I/II/III》《银河帝国系列》《C 语言入门》一本也没有看完。整个暑假网站没有任何修复和改进，编程能力没有一点长进，更别说文学素养什么的了…… 倒是补了不少视频，跟着玄机科技的更新速度看完了《天行九歌》《武庚纪 I/II》《斗罗大陆》，刷完了几部电视剧《猎毒人》《芸汐传》《灵魂摆渡第一季 / 第二季》，尤其被《芸汐传》女主鞠婧祎大大圈粉了，美到融化。还有，在 8 月 10 日约了班上玩的挺好的一堆同学去观影《爱情公寓》…… <del>还真是一部烂剧啊</del> 看的时候感觉很尬——这是我第一次去电影院，很激动。当然，以前没有看过的其他电影我也趁着暑假安排上了，《蜘蛛侠》《变形金刚 I/II/III》《雷神 I/II/III》《加勒比海盗 I/II/III/IV/V》《灵魂摆渡•黄泉》等等，刷的太多现在也记不清了…… 这种感觉真是痛快啊！</p>
<blockquote>
<p>倘若这回还像曾经执着
心执念你一个
那我可能是多情了</p>
</blockquote>
<p>9 月 2 日，我和父亲坐了 25 个小时左右的特快列车来到哈尔滨，踏上北国重镇的土地，然后从火车站乘出租车到达了哈尔滨工程大学。晚上放下行李安排好寝室的事情，我就准备送父亲到预订的宾馆里入住。晚上父亲还和我从前的老师在这个地方谈了一晚上。这是什么老师呢？他是我小学 3 年级以后的英语老师，当时他还是一个帅气的东北小哥儿。他对我尤其关照，虽然身为英语老师，但也关心我的数学成绩，还特意给我打印资料。有一次大家考的好，他还带着几个成绩不错的学生出去爬山，在一个 5A 级森林公园游山玩水照相留念。我离开小学后不久他也离职参加别的工作了，初中高中他也偶尔关心我的发展，真是一个难得的好老师。9 月 4 号，父亲来见了我一面后只身离开了哈尔滨。我以为，从此再也没有人约束我了……</p>
<p>大学就这样开始了，不像别人在大学里可能还会有熟人，我是今年学校来哈工程的唯一一个，全校这届来哈尔滨的好像也只有两人。这就意味着我将要在这里建立一个全新的朋友圈（凭借炉火纯青的表情包交流法）。</p>
<p>在进入大学前我已经认识了不少有意思的校友。借着这些暑假水群认识的学长学姐同学朋友呢，我又顺利通过面试进入学院实践部成为其中一员，得到了通过实践活动锻炼自己拓宽视野的机会。开学后的这段日子，我除了认真地对待各类文体、实践活动，基本一无所获。课业几尽荒废，各种课程除了第一堂课抱着看热闹的新鲜劲儿认真听过，之后的课全在打瞌睡与看手机中度过，即使偶尔心血来潮翻开书本，我也会因为落下的课程而无法理解正在进行的章节，然后就选择继续打瞌睡看手机…… 目前所有科目都已经结课，大学计算机基础、普通化学、武术（体育选修）更是都已经考完期末考试了。我剩下的时间就是全力攻克《线性代数与解析几何》《微积分（上）》了。我希望普化期末的奇迹（完全没听课的情况下考前突击一周摸透书本主要知识点并得到 80 分的成绩）能继续上演在线性代数和微积分上，那我这学期就圆满了。<strong>我终于体会到了大学自学能力的重要性</strong>。</p>
<blockquote>
<p>浊酒一杯余生不悲不喜
何惧爱恨别离
一路纵马去斟酌</p>
</blockquote>
<p>当然，来到大学另一件重要的事当然就是 <strong>谈恋爱</strong> 啦。久闻大学开放自由的气氛，我早就幻想着能赶快开始一段感情吧。在校园里，走路能碰到牵手的情侣，吃饭能碰到喂饭的情侣，自习能碰到讲题的情侣…… 基本上我已经解锁了情侣亲昵的各种姿势。初见也许没什么大不了，可见多了便时常羡慕那种甜蜜的感觉。2018 的下半年我不停地在「单身多好」与「好想谈恋爱啊」两个状态之间切换，身心俱疲。有的时候我会很享受独处的时光，独自漫步校园，随手拍几张照片，瞟几眼路过的漂亮小姐姐，好不自在…… 有的时候我又感到伤心，十七年光阴无丝毫情感经历，就算脱离了父母学校的约束也还是摆脱不了单身的命运，面对钟意之人也不好意思面对面搭讪，倒总是习惯面对手机屏幕借着一张张滑稽可笑的表情传递心意。</p>
<p>准确的说，进入大学没多久，我便发现了那个让我眼前一亮的女生。也算是机缘巧合，我和她都是被实践部副部长抓来完成主持任务的人。那是实践部组织的校园一年一度的「校园吉尼斯」活动，需要两个主持人。由于活动时间是开学刚一个月左右，大家都还处在羞涩内敛的状态，没有人报名，然后…… 然后我就莫名其妙在我副部的推荐下成了主持人。第一眼见她的名字，是在活动分块负责人名单上，一眼扫过去都是实践部的学长学姐，我还以为她也是我学姐。活动开始前她用 QQ 电话召唤了我，我见到了她——不知道是因为心理作用还是咋滴了，我第一眼便有种想叫学姐的冲动 23333，她看起来仙气十足，洋溢着阳光青春的气息，十分大方。我习惯性地避开了她的眼睛，然后认真地和她一起准备主持稿（前一天晚上各自写好的）等等…… 我和她见面的机会基本都在实践部的活动上，我时常因为能与这只小仙女一起活动而傻乐呵，在双十一圣诞节几次脱单大潮中，我甚至有冲动想随口表白一下，但最后都以各种理由放弃了。毕竟冲动是魔鬼，还是静静等待合适的人和时机吧，而且…… 我也不希望给她留下轻佻随便的印象。</p>
<p>不过和我的室友一比，我这些还算弟弟行为吧。室友的日常是这样：「快一起撩小姐姐啊」「你看你看这个怎么样」「哎，把那个小姐姐推给我，我要加」「今天我看到一个特别漂亮的女生」…… 我几乎不在他们面前讨论女生，而且我觉得他们这种行为尤其是集体加一个女生的行为让我反感。我不懂有些人为什么都喜欢广泛撒网，把女生当做任自己挑选的玩物。我觉得这样玩弄别人很不好，emmmmmmmmm。</p>
<blockquote>
<p>一曲相思入江水与山河
在油伞下走过
悠然入梦却恍如昨</p>
</blockquote>
<p>言多必失，就此打住吧。 2018 已经过去永远也不会再来了，这一次，我要立下目标，只要期末全通过我便寻觅钟意之人开启一段轰轰烈烈的爱情，就算学习再忙也不能误了 4 年青春。在接下来的一年，我要：</p>
<ul>
<li>在课业学习上不再荒废</li>
<li>基本掌握 C 语言和单片机基础知识</li>
<li>完成两件有实际意义的单片机作品</li>
<li>制作一至两套 Typecho 主题</li>
<li>找到可以陪我过情人节的意中人</li>
<li>尽自己所能给她最美的回忆</li>
</ul>
<p><strong>2019 愿各位都能不负韶华，对得起自己所有的付出。</strong></p>
]]></content>
    </entry>
</feed>